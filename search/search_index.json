{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#what-is-this-about","title":"What is this about","text":"<p>Collection of notes and resources about data structures and algorithms.</p> <ul> <li>Algorithms - This contains all about algorithms analysis, time complexity,     and different algorithms on data structure.</li> <li>Data Structures - This contains implementation on data structures in C++  and Java </li> </ul>"},{"location":"resources/","title":"Resources","text":"Platforms and competitions <ul> <li>Competitive Programming<ul> <li>https://codeforces.com - in russian and english</li> <li>https://atcoder.jp/home - in japanese and english</li> <li>https://www.codechef.com</li> </ul> </li> <li>Learn some Programming Language<ul> <li>https://exercism.org</li> <li>https://www.hackerrank.com</li> <li>https://www.codewars.com</li> </ul> </li> <li>Interview Questions<ul> <li>https://leetcode.com</li> <li>https://www.lintcode.com</li> <li>https://open.kattis.com</li> <li>https://practice.geeksforgeeks.org/</li> <li>https://www.hackerearth.com</li> <li>https://www.interviewbit.com</li> </ul> </li> <li>Online Judges<ul> <li>https://onlinejudge.org also called UVa - https://en.wikipedia.org/wiki/UVa_Online_Judge</li> <li>https://www.spoj.com - also have vast problems library and programming language support</li> <li>https://acm.timus.ru</li> </ul> </li> <li>Mathematics<ul> <li>https://projecteuler.net/</li> <li>https://cses.fi/problemset/</li> </ul> </li> </ul> Visualizations <p>Visualizations help us to understand algorithms and data structures in a more intuitive way.</p> <ul> <li>https://visualgo.net/en</li> <li>https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</li> <li>https://github.com/algorithm-visualizer/algorithm-visualizer</li> </ul> Cheat Sheets <ul> <li>https://github.com/TheAlgorithms - algorithms implemented in almost all programming languages</li> <li>https://cooervo.github.io/Algorithms-DataStructures-BigONotation/</li> </ul> Books <ul> <li>https://jeffe.cs.illinois.edu/teaching/algorithms/</li> </ul>"},{"location":"algorithms/","title":"Algorithm","text":"<p>Algorithm is series of steps to solve a problem. In computer science an algorithm is used to solve problems. Algorithm is a finite sequence of rigorous instructions, typically used to solve a class of specific problems or to perform a computation.</p> <ul> <li>What is algorithm, space and time complexity?</li> <li>Measuring space and time complexity<ul> <li>How we measure space and time complexity of algorithm depend on the computational model    we are trying to use. Generally we use turing model of computing.</li> </ul> </li> <li>Why study analysis of algorithms?<ul> <li>Some algorithms are fast some are slow. Some take more space and some less.</li> <li>To choose which algorithm to use we should have some analytical tools; these are provided by analysis of algorithms</li> </ul> </li> </ul>"},{"location":"algorithms/#time-complexity","title":"Time complexity","text":"<ul> <li>Big \\(O\\) notation</li> <li>lower bound, upper bound, tight bound</li> <li>pseudo polynomial time, amortized time complexity</li> <li>P vs NP: P, NP, NP-Complete, NP-Hard</li> </ul>"},{"location":"algorithms/#arrays","title":"Arrays","text":"<ul> <li>sorting</li> <li>searching</li> </ul>"},{"location":"algorithms/#trees","title":"Trees","text":"<ul> <li>Types: n-ary, complete tree, binary</li> <li>Binary Trees<ul> <li>Traversal: - inorder, preorder, postorder, level order</li> <li>Operations: insert, delete, search</li> <li>Binary Heap</li> <li>Binary search tree<ul> <li>Self balancing trees - AVL trees, red black trees</li> </ul> </li> <li>Segment Trees</li> <li>Trie</li> <li>Binary Index Trees</li> </ul> </li> </ul>"},{"location":"algorithms/#graphs","title":"Graphs","text":"<ul> <li>Types: directed, undirected, weighted, cyclic, acyclic</li> <li>Traversal: bfs, dfs</li> <li>Operations<ul> <li>Check for cycle in graph</li> <li>Find connected components</li> </ul> </li> <li>Minimum spanning tree<ul> <li>Kruskal Algorithm</li> <li>Prim algorithms</li> <li>Brovuka'a Algorithm</li> </ul> </li> <li>Shortest path from source to all other nodes<ul> <li>djkstra's</li> <li>bellman ford's</li> </ul> </li> <li>Shortest path between all nodes to all other node<ul> <li>floyd warshall</li> <li>Johnson's Algorithm</li> </ul> </li> <li>Directed Acyclic Graph (DAG): topological traversal</li> <li>dfs-tree</li> <li>bfs-tree</li> <li>Connectivity<ul> <li>Path between two vertices</li> <li>Bridges in a graph</li> <li>Articulation Points</li> <li>Eulerian Path</li> </ul> </li> <li>Maximum Flow</li> <li>Union Find</li> </ul>"},{"location":"algorithms/#range-queries","title":"Range Queries","text":"<ul> <li>Segment Tree</li> <li>Binary Index Trees</li> <li>sqrt decomposition</li> </ul>"},{"location":"algorithms/#strings","title":"Strings","text":"<ul> <li>Pattern Matching<ul> <li>KMP method</li> <li>rabin karp method</li> </ul> </li> <li>Trie</li> </ul>"},{"location":"algorithms/#hashing","title":"Hashing","text":"<ul> <li>simple hashing</li> <li>collision on hashing</li> </ul>"},{"location":"algorithms/#algorithm-techniques","title":"Algorithm Techniques","text":"<ul> <li>Brute force</li> <li>Two Pointer</li> <li>Prefix Sum</li> <li>Monotonic Stack</li> <li>Sliding Window</li> <li>Greedy Algorithms - knapsack</li> <li>Dynamic Programming - 0/1 knapsack algorithm, coin selection</li> <li>Divide and Conquer - binary search, merge sort, quick sort</li> <li>Bitwise algorithms</li> <li>Backtracking</li> <li>Randomized Algorithms</li> <li>Branch and Bound</li> </ul>"},{"location":"algorithms/#resources","title":"Resources","text":"<ul> <li>https://en.wikipedia.org/wiki/Algorithm</li> </ul>"},{"location":"algorithms/flow-chart/","title":"Flow Chart for solving problem","text":"<pre><code>flowchart TD\n    A([Start]) --&gt; B[is it a hashmap problem?]\n    B --&gt; sort[will sorting help?]\n    sort --&gt; binary_search[is it binary search?]\n    binary_search --&gt; dp[is it dynamic programming?]\n    dp --&gt; greedy[is it greedy?]\n    greedy --&gt; Graph[graph problem?]\n    Graph --&gt; tree[tree problem?]\n    tree --&gt; simulation[simulation problem?]\n    simulation --&gt; mono_stack[monotonic stack?]\n    mono_stack --&gt; two_pointers[two pointers]\n     --&gt; Z([Stop])</code></pre>"},{"location":"algorithms/arrays/searching/","title":"Searching","text":"<p>Searching through a items of objects is one of the basic operations.</p> <p>Basic method to search is called linear search, in this you go through the list of items one by one and compare.</p> <p>Other was to search is if the items are sorted by the value which you are searching.</p> <p>Here you check the middle of the items and eliminate the need to check one half of the array.</p>"},{"location":"algorithms/arrays/searching/binary_search/","title":"Binary Search","text":"<pre><code>int binary_search(vector&lt;int&gt; arr, int item){\n    int start = 0, end = arr.size() - 1;\n    int ans = -1; // -1 means element not found\n\n    while(start &lt;= end){\n        int mid = start + (end - start) / 2;\n        if(arr[mid] == item){\n            ans = item;\n            break;\n        }\n        else if(arr[mid] &lt; item){\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n</code></pre> <p>There is also a recursive way to do binary search.</p> <pre><code>int binary_search(vector&lt;int&gt; arr, int start, int end, int target){\n    if(start &lt; end) return -1; // element not found\n    int mid = start + (end - start) / 2;\n    if(arr[mid] == target) \n        return mid;\n    else if(arr[mid] &lt; target) \n        return binary_search(arr, mid + 1, end, target);\n    else \n        return binary_search(arr, start, mid - 1, target);\n}\n</code></pre> <p>Here are some question which will use binary search with some modifications</p> <ul> <li>Divide a sorted array in two parts and then change position of the parts   do binary search in this array</li> <li>Find the lower bound and upper bound of given element</li> <li>Given a monotonic increasing function, we have to find a value which will give   a particular result from the function</li> </ul>"},{"location":"algorithms/arrays/searching/binary_search/#lower-bound-of-k-element-that-is-greater-than-and-equal-to-k","title":"Lower bound of k, element that is greater than and equal to k","text":"<pre><code>int lower_bound(vector&lt;int&gt; arr, int target){\n    int start = 0, end = arr.size() - 1;\n    int ans = arr.size();\n    while(start &lt;= end){\n        int mid = start + (end - start) / 2;\n        if(arr[mid] &gt;= target){\n            ans = mid;\n            end = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"algorithms/arrays/searching/binary_search/#upper-bound-of-k-first-element-that-is-greater-than-k","title":"Upper bound of k, first element that is greater than k","text":"<pre><code>int upper_bound(vector&lt;int&gt; arr, int target){\n    int start = 0, end = arr.size() - 1;\n    int ans = arr.size();\n    while(start &lt;= end){\n        int mid = start + (end - start) / 2;\n        if(arr[mid] &gt; target){\n            ans = mid;\n            end = mid - 1;\n        } else {\n            start = mid + 1;\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"algorithms/arrays/searching/binary_search/#resources-for-binary-search","title":"Resources for binary search","text":"<ul> <li>https://cp-algorithms.com/num_methods/binary_search.html</li> <li>https://www.techiedelight.com/binary-search-interview-questions</li> <li>https://usaco.guide/silver/binary-search</li> </ul>"},{"location":"algorithms/arrays/sorting/","title":"Sorting","text":"<p>Sorting is one of the basic operation you can perform on a given collection of item. For sorting you need some basis of comparison and the order in which you want to sort.</p> <p>A simple use of sorting is when you want to search form item many times you can sort them and then use binary search.</p> <p>Also note that you cannot make a sorting algorithm with time complexity less than \\(O(\\log n)\\) if we use the comparison model for computation.</p> <p>Here is list of some common sorting algorithms:</p> <ul> <li>Bubble Sort</li> <li>Insertion Sort</li> <li>Selection Sort</li> <li>Heap Sort</li> <li>Count Sort</li> <li>Quick Sort</li> <li>Merge Sort</li> <li>Radix Sort</li> </ul>"},{"location":"algorithms/arrays/sorting/bubble/","title":"Bubble Sort","text":""},{"location":"algorithms/arrays/sorting/bubble/#intuition","title":"Intuition","text":"<p>This works as follow, you iterate through the array and check two adjacent elements if the second one is smaller you swap them, in this way the largest number will be at the end of array after first iteration. In second iteration you do the same till the second last element of array, and so on. Also keep a flag to check if any swaps are made in some iteration, if no swaps are made you can stop as the array is already sorted.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid bubble_sort(vector&lt;int&gt;&amp; a) {\n  for (int i = 0; i &lt; a.size(); i++) {\n    bool swap = false;\n    for (int j = 0; j &lt; a.size() - i - 1; j++) {\n      if (a[j + 1] &lt; a[j]) {\n        int temp = a[j + 1];\n        a[j + 1] = a[j];\n        a[j] = temp;\n        swap = true;\n      }\n    }\n    if (!swap) {\n      break;\n    }\n  }\n}\n\nint main() {\n  vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n  bubble_sort(a);\n  for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n  return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/bubble/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n)\\), if the array is sorted</li> <li>Average: \\(O(n^2)\\)</li> <li>Worst: \\(O(n^2)\\)</li> </ul> </li> <li>Space complexity - \\(O(1)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/count/","title":"Count Sort","text":""},{"location":"algorithms/arrays/sorting/count/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>you are given array <code>arr</code> with numbers within range \\([1, n]\\)</li> <li>first you find the relative frequency of all numbers form \\([1, n]\\) in <code>arr</code></li> <li>then you calculate the cumulative frequency</li> <li>now position of a particular element \\(x\\) in the sorted array will be   the cumulative frequency of the \\(x-1\\) because that many elements   will appear before it in the array.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define N 10\n\nvoid count_sort(vector&lt;int&gt; &amp;a) {\n    vector&lt;int&gt; c(N, 0);\n    vector&lt;int&gt; out(a.size(), 0);\n    for (auto i : a) c[i]++;                             // relative freq\n    for (int i = 1; i &lt; c.size(); i++) c[i] += c[i - 1]; // cumulative freq\n    // for (int i = 0; i &lt; a.size(); i++) out[c[a[i] - 1]++] = a[i]; // unstable\n    for (int i = a.size() - 1; i &gt;= 0; i--) out[c[a[i]]-- - 1] = a[i]; // stable\n    a = out;\n}\n\nint main() {\n    vector&lt;int&gt; a = {1, 4, 0, 2, 5, 5, 6, 3, 3, 4};\n    count_sort(a);\n    for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/count/#analysis","title":"Analysis","text":"<ul> <li>\\(k\\) - the range of numbers</li> <li>\\(n\\) - the size of array</li> <li>Time complexity<ul> <li>Best: \\(O(n+k)\\), if the array is sorted</li> <li>Average: \\(O(n+k)\\)</li> <li>Worst: \\(O(n+k)\\)</li> </ul> </li> <li>Space complexity - \\(O(k+n)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/heap/","title":"Heap Sort","text":""},{"location":"algorithms/arrays/sorting/heap/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>make a heap using heapify</li> <li>pop out the elements and put them at the end of the heap</li> </ul> <p>NOTE: In this code I used extra space for the heap, but I can use heapify on the array also so that no extra space will be required.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid heap_sort(vector&lt;int&gt; &amp;a) {\n    /* make a min heap using heapify O(n)*/\n    std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt; pq(std::greater&lt;int&gt;(), a);\n    for (int i = 0; i &lt; a.size(); i++) {\n        a[i] = pq.top();\n        pq.pop();\n    }\n}\n\nint main() {\n    vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n    heap_sort(a);\n    for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/heap/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n \\log(n))\\), if the array is sorted</li> <li>Average: \\(O(n \\log(n))\\)</li> <li>Worst: \\(O(n \\log(n))\\)</li> </ul> </li> <li>Space complexity - \\(O(1)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/insertion/","title":"Insertion Sort","text":""},{"location":"algorithms/arrays/sorting/insertion/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>Consider you have a sorted array and you want to insert a element</li> <li>you will scan through the end of the sorted array and keep on shifting elements to right till   the right position of element you want to insert is not found.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid insertion_sort(vector&lt;int&gt; &amp;a) {\n    int key = 0;\n    for (int i = 1; i &lt; a.size(); i++) {\n        key = a[i];\n        int j = i - 1;\n        while (j &gt;= 0 &amp;&amp; a[j] &gt; key) {\n            a[j + 1] = a[j];\n            j--;\n        }\n        a[++j] = key;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n    insertion_sort(a);\n    for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/insertion/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n)\\), if the array is sorted</li> <li>Average: \\(O(n^2)\\)</li> <li>Worst: \\(O(n^2)\\)</li> </ul> </li> <li>Space complexity - \\(O(1)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/merge/","title":"Merge Sort","text":""},{"location":"algorithms/arrays/sorting/merge/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>divide array into two haves</li> <li>sort both recursively</li> <li>merge both sorted array</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid merge(vector&lt;int&gt;&amp; a, int start, int mid, int end) {\n  vector&lt;int&gt; left(a.begin() + start, a.begin() + mid + 1);\n  vector&lt;int&gt; right(a.begin() + mid + 1, a.begin() + end + 1);\n  int i = 0, j = 0, k = start;\n  while (i &lt; left.size() &amp;&amp; j &lt; right.size()) {\n    if (left[i] &lt; right[j])\n      a[k++] = left[i++];\n    else\n      a[k++] = right[j++];\n  }\n  while (i &lt; left.size()) a[k++] = left[i++];\n  while (j &lt; right.size()) a[k++] = right[j++];\n}\n\nvoid mergeSort(vector&lt;int&gt;&amp; a, int start, int end) {\n  if (start &gt;= end) return;\n  int mid = start + (end - start) / 2;\n  mergeSort(a, start, mid);\n  mergeSort(a, mid + 1, end);\n  merge(a, start, mid, end);\n}\n\nint main() {\n  vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n  mergeSort(a, 0, a.size() - 1);\n  for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n  return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/merge/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n \\log(n))\\), if the array is sorted</li> <li>Average: \\(O(n \\log(n))\\)</li> <li>Worst: \\(O(n \\log(n))\\)</li> </ul> </li> <li>Space complexity - \\(O(n)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/quick/","title":"Quick Sort","text":""},{"location":"algorithms/arrays/sorting/quick/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>choosing a pivot</li> <li>move all elements smaller to left of pivot (larger to right)</li> <li>now recursively sort the two halves</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint partition(vector&lt;int&gt;&amp; a, int start, int end) {\n  int pivot = a[end]; // chossing pivot\n  int i = start - 1;  // smaller elements counter\n  for (int j = start; j &lt;= end; j++) {\n    if (a[j] &lt; pivot) swap(a[++i], a[j]);\n  }\n  swap(a[++i], a[end]);\n  return i;\n}\n\nvoid quick_sort(vector&lt;int&gt;&amp; a, int start, int end) {\n  if (start &gt;= end) return;\n  int p = partition(a, start, end);\n  quick_sort(a, start, p - 1);\n  quick_sort(a, p + 1, end);\n}\n\nint main() {\n  vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n  quick_sort(a, 0, a.size() - 1);\n  for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n  return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/quick/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n \\log(n))\\), if the array is sorted</li> <li>Average: \\(O(n \\log(n))\\)</li> <li>Worst: \\(O(n^2)\\)</li> </ul> </li> <li>Space complexity - \\(O(1)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/radix/","title":"Radix Sort","text":""},{"location":"algorithms/arrays/sorting/radix/#intuition","title":"Intuition","text":"<p>This works as follow,</p> <ul> <li>you count sort all no. based on their last digit</li> <li>then count sort all no. based on second last digit, and so on...</li> <li>till we sort by the no. of digits in the largest no.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n#define N 10 // N base of the number system used\n\nvoid count_sort(vector&lt;int&gt; &amp;a, int exp) {\n    vector&lt;int&gt; out(a.size(), 0);\n    vector&lt;int&gt; c(N + 1, 0);                      // count for the digits\n    for (auto i : a) c[(i / exp) % 10]++;         // relative freq\n    for (int i = 1; i &lt; N; i++) c[i] += c[i - 1]; // cumulative freq\n    for (int i = a.size() - 1; i &gt;= 0; i--) out[--c[(a[i] / exp) % 10]] = a[i];\n    a = out;\n}\n\nvoid radix_sort(vector&lt;int&gt; &amp;a) {\n    // calculate max to get max no of digits\n    int m = *max_element(a.begin(), a.end());\n    for (int exp = 1; m / exp &gt; 0; exp *= 10) count_sort(a, exp);\n}\n\nint main() {\n    vector&lt;int&gt; a = {170, 45, 75, 90, 802, 24, 2, 66};\n    radix_sort(a);\n    for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/radix/#analysis","title":"Analysis","text":"<ul> <li>\\(d\\) - the number of digits in number</li> <li>\\(b\\) - the base of the numbers to be sorted</li> <li>Time complexity<ul> <li>Best: \\(O(d (n+b))\\), if the array is sorted</li> <li>Average: \\(O(d (n+b) )\\)</li> <li>Worst: \\(O(d (n+b))\\)</li> </ul> </li> <li>Space complexity - \\(O(n+b)\\)</li> </ul>"},{"location":"algorithms/arrays/sorting/selection/","title":"Selection Sort","text":""},{"location":"algorithms/arrays/sorting/selection/#intuition","title":"Intuition","text":"<p>This works as follow, you pick the smallest element and put it in first, and then you pick the smallest form the remaining elements and put it in the second, and so on.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nvoid selection_sort(vector&lt;int&gt; &amp;a) {\n    for (int i = 0; i &lt; a.size(); i++) {\n        int mini = i;\n        for (int j = i + 1; j &lt; a.size(); j++) {\n            if (a[j] &lt; a[mini]) mini = j;\n        }\n        int temp = a[mini];\n        a[mini] = a[i];\n        a[i] = temp;\n    }\n}\n\nint main() {\n    vector&lt;int&gt; a = {1, 4, 2, 5, 5, 6, 3, 3, 4};\n    selection_sort(a);\n    for (auto i : a) cout &lt;&lt; i &lt;&lt; \" \";\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/arrays/sorting/selection/#analysis","title":"Analysis","text":"<ul> <li>Time complexity<ul> <li>Best: \\(O(n)\\), if the array is sorted</li> <li>Average: \\(O(n^2)\\)</li> <li>Worst: \\(O(n^2)\\)</li> </ul> </li> <li>Space complexity - \\(O(1)\\)</li> </ul>"},{"location":"algorithms/graphs/all-pair-shortest-path/","title":"All pair shortest path","text":"<ul> <li>The aim of these algorithms is to find the shortest path between   every pair of vertices if one exists.</li> </ul>"},{"location":"algorithms/graphs/all-pair-shortest-path/#floyids-warsall","title":"Floyids Warsall","text":"<ul> <li>https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm</li> </ul>"},{"location":"algorithms/graphs/all-pair-shortest-path/#sample-implementation","title":"Sample Implementation","text":"<pre><code>// all pair shortest path\n// use transitive property\n\n#include &lt;bits/stdc++.h&gt;\n\n#define INF 99999\n\nusing namespace std;\n\nvoid printMatrix(vector&lt;int&gt; graph[]) {\n    cout &lt;&lt; \"\\n\";\n    for (int i = 0; i &lt; (*graph).size(); i++) {\n        for (int j = 0; j &lt; graph[i].size(); j++) {\n            if (graph[i][j] == INF) {\n                cout &lt;&lt; \"*\\t\";\n                continue;\n            }\n            cout &lt;&lt; graph[i][j] &lt;&lt; \"\\t\";\n        }\n        cout &lt;&lt; \"\\n\";\n    }\n}\n\nvoid floyd(vector&lt;int&gt; graph[], int V) {\n    vector&lt;int&gt; dist[V];\n\n    for (int i = 0; i &lt; V; i++) {\n        dist[i] = graph[i];\n    }\n\n    cout &lt;&lt; \"(flyod):: printing dist \";\n    printMatrix(dist);\n\n    for (int i = 0; i &lt; V; i++) {\n        for (int j = 0; j &lt; V; j++) {\n            for (int k = 0; k &lt; V; k++) {\n                // if (dist[i][j] == INT_MAX) {\n                //     // cannot be connected\n                //     if (dist[i][k] == INT_MAX || dist[k][j] == INT_MAX) {\n                //         // still cannot be reached\n                //         dist[i][j] == INT_MAX;\n                //     } else {\n                //         dist[i][j] = dist[i][k] + dist[k][j];\n                //     }\n                // } else if (dist[i][k] == INT_MAX || dist[k][j] == INT_MAX) {\n                //     // don't change\n                //     dist[i][j] = dist[i][j];\n                // }\n                if (dist[i][j] &gt; dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n        cout &lt;&lt; \"(flyod):: printing distance_\" &lt;&lt; i;\n        printMatrix(dist);\n    }\n\n    cout &lt;&lt; \"(flyod):: printing dist final \";\n    printMatrix(dist);\n}\n\nint main() {\n    int V = 4;\n    vector&lt;int&gt; graph[V] = {\n        {0, 12, INF, 1},\n        {12, 0, 4, 7},\n        {INF, 4, 0, 3},\n        {1, 7, 3, 0}};\n\n    cout &lt;&lt; \"(main):: printing graph\";\n    printMatrix(graph);\n\n    // Print the solution\n    floyd(graph, V);\n    cout &lt;&lt; \"(main):: printing graph after flyod\";\n    printMatrix(graph);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/graphs/all-pair-shortest-path/#johnsons-algorithm","title":"Johnson's Algorithm","text":"<ul> <li>https://en.wikipedia.org/wiki/Johnson%27s_algorithm</li> </ul>"},{"location":"algorithms/graphs/bipartite-graph/","title":"Bipartite Graph","text":"<ul> <li>Given graph check whether it is bipartite or not?</li> </ul>"},{"location":"algorithms/graphs/bridges/","title":"Bridges","text":"<ul> <li>to find bridges</li> <li>you need a dfs-tree</li> <li> <p>in dfs-tree</p> <ul> <li>every edge that has no backedge or   its child nodes don't have a backedge to the to the parent node or above nodes   is a bridge</li> <li>no backedge is bridge, because we just reached that node with other edges</li> </ul> </li> <li> <p>so to get these node</p> </li> <li>you can assign a entry time to all node, the time when you entered them</li> <li>and them you can assign the lowest node they can reach to - low,   which can be update by iterating all adjacent node and the child node value,   in the end if an node low value is not less than its reaching value   then it is connected with the bridge.</li> </ul>"},{"location":"algorithms/graphs/cycles-detection/","title":"Checking for Cycle in Graph","text":"<p>How to detect cycle in graphs (directed or undirected graph). Methods which exist are using colors, negative cycle using floyd warshalls or bellman ford.</p>"},{"location":"algorithms/graphs/cycles-detection/#problems","title":"Problems","text":"<ul> <li>Assign directions to edges so that the graph remain acyclic</li> <li>Clone a directed acyclic graph</li> <li>Disjoint set</li> </ul>"},{"location":"algorithms/graphs/directed-acyclic-graph/","title":"Directed Acyclic Graph (DAG)","text":"<ul> <li>Directed acyclic graph, is a digraph with no cycles.</li> <li>DAG are used in many places like, dependencies of project,   prerequisites of a course.</li> </ul>"},{"location":"algorithms/graphs/directed-acyclic-graph/topological-sort/","title":"Topological sort","text":"<p>possible only for directed acyclic graphs</p> <ul> <li>find all possible topological graphs</li> <li>methods<ul> <li>dfs</li> <li>khan's algo</li> </ul> </li> <li>maximum edges that can be added to dag so it still remains dag</li> <li>longest path between pair of vertices</li> <li>longest path in dag</li> </ul>"},{"location":"algorithms/graphs/directed-acyclic-graph/topological-sort/#sample-implementation","title":"Sample Implementation","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\n\nusing namespace std;\n\nvoid topsortutil(vector&lt;vector&lt;int&gt;&gt; graph, stack&lt;int&gt; &amp;st, int i, bool *visited) {\n    cerr &lt;&lt; \"(top):: visiting \" &lt;&lt; i &lt;&lt; \" vertex\\n\";\n    visited[i] = true;\n    for (int j = 0; j &lt; graph[i].size(); j++) {\n        if (!visited[graph[i][j]]) {\n            cerr &lt;&lt; \"(top):: visiting \" &lt;&lt; graph[i][j] &lt;&lt; \" now\\n\";\n            topsortutil(graph, st, graph[i][j], visited);\n        }\n    }\n    cerr &lt;&lt; \"(top):: pushing \" &lt;&lt; i &lt;&lt; \" \\n\";\n    st.push(i);\n}\n\nvoid topological_sort(vector&lt;vector&lt;int&gt;&gt; graph) {\n    /* make a visited array */\n    bool visited[graph.size()] = {false};\n    stack&lt;int&gt; st;\n    for (int i = 0; i &lt; graph.size(); i++) {\n        if (!visited[i]) {\n            cerr &lt;&lt; \"(top_sort):: edge \" &lt;&lt; i &lt;&lt; \" not visited -&gt; visiting\\n\";\n            topsortutil(graph, st, i, visited);\n        }\n    }\n\n    while (!st.empty()) {\n        cout &lt;&lt; st.top() &lt;&lt; \"-&gt;\";\n        st.pop();\n    }\n}\n\nint main() {\n    int v; // no of vertices\n    int e; // no of edges\n    cout &lt;&lt; \"no of edges: \";\n    cin &gt;&gt; e;\n    cout &lt;&lt; \"no of vertices: \";\n    cin &gt;&gt; v;\n\n    vector&lt;vector&lt;int&gt;&gt; graph(v); // make a graph to store v vertices\n\n    // now insert edges in int\n    cout &lt;&lt; \"enter the edges now in form (source, destination)::\\n\";\n    for (int i = 0; i &lt; e; i++) {\n        int source, destination;\n        cin &gt;&gt; source &gt;&gt; destination;\n        graph[source].push_back(destination); // insert the edge\n    }\n\n    topological_sort(graph);\n\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/graphs/disjoint-union/","title":"Disjoint Union","text":"<ul> <li> <p>https://en.wikipedia.org/wiki/Disjoint-set_data_structure</p> </li> <li> <p>Redundant Connection</p> </li> </ul>"},{"location":"algorithms/graphs/eulerian-graph/","title":"Eulerian Graph","text":"<ul> <li>Eulerian graph is the one which consists a Eulerian circuit.</li> <li>Eulerian circuit is a path which traverse each edge exactly once     and return to the starting circuit.</li> </ul> <p>This is different from Hamiltonian path as here we focus on edge and not on vertex.</p>"},{"location":"algorithms/graphs/graph-coloring/","title":"Graph Coloring","text":"<p>What is the minimum number of colors required to color the nodes of the graph such that no two adjacent nodes have the same color?</p>"},{"location":"algorithms/graphs/graph-diameter/","title":"Graph Diameter","text":"<ul> <li>What is the diameter of the graph, i.e., the longest shortest path between any two nodes?</li> </ul>"},{"location":"algorithms/graphs/hamiltonian-cycle/","title":"Hamiltonian Cycle","text":"<ul> <li>Determine if a path exists that visits each node once.</li> </ul>"},{"location":"algorithms/graphs/minimum-spanning-tree/","title":"Minimum Spanning Tree","text":"<p>For this a weighted graph is required. Minimum spanning tree of a graph is set of all the edges which connect all the vertices of the graph with the minimum total weight. The aim is to find a minimum spanning tree. There can be multiple minimum spanning tree for a graph.</p>"},{"location":"algorithms/graphs/minimum-spanning-tree/kruskal/","title":"Kruskal's Algorithm","text":""},{"location":"algorithms/graphs/minimum-spanning-tree/prims/","title":"Prims Algorithm","text":""},{"location":"algorithms/graphs/network-flow/","title":"Network flow in graphs","text":"<ul> <li>Given all input resources are unlimited what is the maximum flow that   can be achieved through the graph.</li> </ul>"},{"location":"algorithms/graphs/planarity-testing/","title":"Planarity Testing","text":"<p>Is given graph planer or not. A graph is planer if we can draw it on plane without any of it's edges intersecting.</p>"},{"location":"algorithms/graphs/shortest-path/","title":"Shortest Path Algorithms","text":"<p>Aim of these algorithm is to find, shortest path between two vertices in a weighted graph.</p> <p>This problem is equivalent to finding shortest path between a given edge to every other edge in graph.</p> <ul> <li>Johnson's Algorithm</li> </ul>"},{"location":"algorithms/graphs/shortest-path/djstra/","title":"Dijkstras Shortest Path Algorithm","text":""},{"location":"algorithms/graphs/shortest-path/djstra/#intuition","title":"Intuition","text":"<p>Given:</p> <ul> <li>you have some nodes</li> <li>some edges which have some weight assigned to them</li> <li>and you have one node for which we have to find</li> <li>shortest path to all other edges</li> </ul> <p>Setup:</p> <ul> <li>you create two arrays<ul> <li>array which contain the shortest distance to that node</li> <li>and the source node through which you will reach this node, this help in reconstruction of path</li> </ul> </li> </ul> <p>Algorithm:</p> <ul> <li>Create a set</li> <li>assign all the elements the distance \\(+\\infty\\) except source node which is \\(0\\)</li> <li>now repeat these steps till all nodes are not in the set<ul> <li>choose the node with smallest distance and which is not in the set</li> <li>add that to the set</li> <li>now check for all adjacent nodes of the picked node<ul> <li>if path through node is smaller or not</li> <li>\\(d(a, b) = \\min(d(a, c) + d(c, b))\\)</li> <li>if yes update distance and source to this node</li> </ul> </li> </ul> </li> <li>now you have shortest distance</li> </ul>"},{"location":"algorithms/graphs/strongly-connected-components/","title":"Strongly Connected Components","text":""},{"location":"algorithms/graphs/strongly-connected-components/#tarjans-algorithm","title":"Tarjan's Algorithm","text":"<ul> <li>https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm</li> </ul>"},{"location":"algorithms/graphs/strongly-connected-components/#kosarajus-algorithm","title":"Kosaraju's Algorithm","text":"<ul> <li>https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm</li> </ul>"},{"location":"algorithms/graphs/travelling-salesman-problem/","title":"Traveling Salesman Problem","text":"<ul> <li> <p>What is the shortest path that visits all nodes in the graph exactly once and returns to the starting node?</p> </li> <li> <p>This is equivalent question - determine the shortest path of a hamiltonian cycle.</p> </li> </ul>"},{"location":"algorithms/graphs/traversal/","title":"Graph Traversal","text":"<p>There are two main methods of graph traversal.</p> <ul> <li>Depth First Search</li> <li>Breadth First Search</li> </ul>"},{"location":"algorithms/graphs/traversal/bfs-tree/","title":"BFS-Trees","text":"<ul> <li>tree we made while traversing a graph in bfs style</li> <li>problems<ul> <li>level order traversal</li> </ul> </li> </ul>"},{"location":"algorithms/graphs/traversal/bfs/","title":"Breadth First Search","text":""},{"location":"algorithms/graphs/traversal/dfs-tree/","title":"DFS-Trees","text":"<p>DFS Tree is the data structure which is created by dfs traversal of the graph. Read https://codeforces.com/blog/entry/68138 for more detailed description.</p>"},{"location":"algorithms/graphs/traversal/dfs/","title":"Depth First Search","text":""},{"location":"algorithms/techniques/","title":"Algorithmic Techniques","text":"<p>Several methods are used to solve problems in competitive programming. Sometime we may have to use one or more technique in combination with each other.</p> <p>Here are some common method which are used:</p>"},{"location":"algorithms/techniques/#broad-category-of-methods","title":"Broad Category of Methods","text":"<ul> <li>Divide and Conquer</li> <li>Dynamic Programming</li> <li>Greedy</li> </ul>"},{"location":"algorithms/techniques/#special-techniques","title":"Special Techniques","text":"<ul> <li>Sliding Window</li> <li>Two Pointer</li> <li>Sweep Line</li> <li>Monotonic Stack</li> <li>[Fast and Slow Pointers]</li> <li>[Two Heaps]</li> <li>[Binary Search]</li> </ul>"},{"location":"algorithms/techniques/#using-special-data-structure","title":"Using Special Data Structure","text":"<ul> <li>[Disjoint Set]</li> <li>[Trie]</li> </ul>"},{"location":"algorithms/techniques/#tricks-rather-than-algorithms","title":"Tricks rather than algorithms","text":"<ul> <li>Bit Manipulation</li> </ul>"},{"location":"algorithms/techniques/#unique-articles","title":"Unique Articles","text":"<ul> <li>https://en.wikipedia.org/wiki/Cycle_detection</li> </ul>"},{"location":"algorithms/techniques/backtracking/","title":"Backtracking","text":"<ul> <li>rat in the maze</li> <li>n-queens problem</li> <li>m-coloring problem</li> <li>hamiltonian cycle</li> <li>permutation of numbers such that the sum of two consecutive numbers is a prefect square</li> </ul>"},{"location":"algorithms/techniques/bit-manipulation/","title":"Bit Manipulation","text":"<p>We have binary computers, that is they operate on bits. So if we can utilize this property clearly we can greatly improve the efficiency of our algorithm.</p>"},{"location":"algorithms/techniques/bit-manipulation/#how-to-get-the-total-no-of-bits-for-a-data-type","title":"how to get the total no of bits for a data type","text":"<pre><code>// to get the no of bits for a data type\nint noBits = sizeof int * 8;\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#list-of-bitwise-operators","title":"list of bitwise operators","text":"<ul> <li><code>&amp;</code> and - this operators do and of two numbers</li> <li><code>|</code> or - this does the or of bits of two numbers</li> <li><code>~</code> not - this inverts all the bits in the number</li> <li><code>^</code> xor - this does the xor, xor of two bits is true if both bits are different</li> <li><code>&lt;&lt;n</code> left shift - this shift the bits to left <code>n</code> no of times, the bits are filled with 0.</li> <li><code>&gt;&gt;n</code> right shift - this shift the bits to right <code>n</code> no of times, the new bits are filled with 0.</li> </ul>"},{"location":"algorithms/techniques/bit-manipulation/#notes","title":"notes","text":"<ul> <li>The result of a right-shift of a signed negative number is implementation-dependent.   So better not use <code>-2 &gt;&gt; 3</code>.</li> <li>If the <code>n</code> is negative the it is undefined behavior.</li> </ul>"},{"location":"algorithms/techniques/bit-manipulation/#how-to-check-if-ith-bit-is-set-or-not-use-and","title":"how to check if i'th bit is set or not - use and","text":"<pre><code>int i=3; // bit to get\nint n = 132;\nint t = n &amp; (1 &lt;&lt; i); // check bit set\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#flip-the-ith-bit-use-xor","title":"flip the i'th bit - use xor","text":"<pre><code>int i = 5; //  bit to filp\nint n = 32432;\nint t = n ^ (1 &lt;&lt; i); // new no with bit flipped\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#compute-xor-from-1-to-n","title":"Compute xor from 1 to n","text":"<pre><code>int n = 100;\ncase(n%4){\n    0: return n;\n    1: return 1;\n    2: return n+1;\n    3: return 0;\n}\n// how this works? - because at intervals of 4 each bit have repeated twice\n// this is clearly visible for 2^n - 1\n// but even for cases where n % 4 == 0, the bits have repeated twice\n// after which the n comes because, 0 ^ n = n\n// after this we get 1, and then n + 1, then 0\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#set-bit-at-position-p","title":"set bit at position p","text":"<pre><code>int n = 123;\nint p = 10;\nn = n &amp; (~(1 &lt;&lt; p));\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#powers-of-2","title":"powers of 2","text":""},{"location":"algorithms/techniques/bit-manipulation/#check-if-no-is-power-of-two","title":"check if no is power of two","text":"<pre><code>int x = 21312;\nif(x==0) return true;\nif(!(x &amp; (x-1))) return true;\n// ans of x ans x - 1 is 0 if it is power of 2\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#multiply-divide-by-2","title":"multiply divide by 2","text":"<pre><code>int x = 213;\nint y = x &gt;&gt; 1; // divide by 2\nint z = x &lt;&lt; 1; // multiply by 2\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#msb-lsb","title":"MSB - LSB","text":"<ul> <li>MSB - most significant bit - the leftmost set bit</li> <li>LSB - least significant bit - first bit to right</li> </ul>"},{"location":"algorithms/techniques/bit-manipulation/#get-the-rightmost-set-bit","title":"get the rightmost set bit","text":"<pre><code>int x = 1021;\n// get a new no with only its right most bit set \n// to that of the no\n// 10100 -&gt; 00100\nint y = x ^ (~x + 1); \n// or\nint y = x ^ -x; // because -x = ~x + 1 two's complement\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#unset-the-rightmost-set-bit","title":"unset the rightmost set bit","text":"<pre><code>int x = 21312;\nint y = x &amp; (x-1);\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#clear-all-bit-from-lsb-to-ith-bit","title":"clear all bit from lsb to ith bit","text":"<pre><code>// [xxxxxi....0]\nint x = 1312;\nint i = 4;\nint mask = ~((1 &lt;&lt; i+1 ) - 1);\nx &amp;= mask;\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#clear-all-bit-from-msb-to-ith-bit","title":"clear all bit from msb to ith bit","text":"<pre><code>// [xx1...ixxxx] [1...i] this will be 0\nmask = (1 &lt;&lt; i) - 1;\nx &amp;= mask;\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#get-the-msb","title":"get the msb","text":"<pre><code>int n = 123;\n// the msb will make it's right adjacent element 1 so now 2 elements are 1\nn = n | (n &amp; n &gt;&gt; 1); \n// now make 4 1's with 2 1's\nn = n | (n &amp; n &gt;&gt; 2);\n// now make 8 1's with 4 1's\nn = n | (n &amp; n &gt;&gt; 4);\n// now make 16 1's with 8 1's\nn = n | (n &amp; n &gt;&gt; 8);\n// now make 32 1's with 16 1's\nn = n | (n &amp; n &gt;&gt; 16);\n// now the number will be all 1's to its msb\n// so we now add 1 and right shift 1 to get it\n// this would overflow on last bit so check if it is last bit too\nreturn ((n+1) &gt;&gt; 1) | (n &amp; (1&lt;&lt;31));\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#upper-case-to-lower-case","title":"upper case to lower case","text":"<pre><code>char c= 'd';\nc ^= 32; // for ascii value character only\n</code></pre>"},{"location":"algorithms/techniques/bit-manipulation/#problems-solved-using-bitwise","title":"Problems solved using bitwise","text":"<ul> <li>all no are repeated even no of time expect one find it<ul> <li>do xor of all elements</li> </ul> </li> <li>swap two numbers without additional variable and arithmetic operators<ul> <li><code>x = x ^ y;</code></li> <li><code>y = x ^ y;</code> - <code>x ^y ^ y</code> which is <code>x</code> so now <code>y</code> have <code>x</code> value</li> <li><code>x = x ^ y;</code> - <code>x ^y ^ x</code> which is <code>y</code>q</li> </ul> </li> <li>find to non-repeating elements <code>x</code> and <code>y</code>, all other elements repeat twice<ul> <li>do xor of all elements you wil get <code>x ^ y</code> as other will cancel out.</li> <li>now if two no are different, which is the first bit they differ on,   it would be the rightmost set bit of their xor( xor is true only if things differ)</li> <li>so you divide no into group according to the right most bit of xor, and then do xor   of the two groups separately. and you will get both no.</li> </ul> </li> </ul>"},{"location":"algorithms/techniques/cyclic-sort/","title":"Cyclic Sort","text":"<ul> <li>Find Missing Number</li> </ul>"},{"location":"algorithms/techniques/divide-and-conquer/","title":"Divide and Conquer","text":"<ul> <li>first you divide in subproblem</li> <li>then you merge them</li> </ul> <p>OR</p> <ul> <li>you do some computation</li> <li>then you crete two or more same subproblem to solve</li> </ul>"},{"location":"algorithms/techniques/divide-and-conquer/#time-complexity","title":"Time Complexity","text":"<ul> <li>you have to make a recurrence relation for time complexity, and then solve it using Masters Theorem.</li> </ul>"},{"location":"algorithms/techniques/divide-and-conquer/#merge-sort","title":"Merge Sort","text":"<ul> <li>split array into two</li> <li>sort them recursively</li> <li>merge them</li> </ul>"},{"location":"algorithms/techniques/divide-and-conquer/#quick-sort","title":"quick sort","text":"<ul> <li>find pivot, and separate elements</li> <li>sort the other parts recursively</li> </ul>"},{"location":"algorithms/techniques/divide-and-conquer/#questions","title":"Questions","text":"<ul> <li>Median of Two Sorted Array</li> </ul>"},{"location":"algorithms/techniques/fast-slow-pointers/","title":"Fast and Slow Pointers","text":"<ul> <li>Linked List Cycle</li> </ul>"},{"location":"algorithms/techniques/greedy/","title":"Greedy Algorithms","text":"<ul> <li>Are optimization algorithms where we have objective to maximize or minimize stuff.</li> <li>Here at each step we make a choice and choose the optimal   case which will lead to solution.</li> </ul>"},{"location":"algorithms/techniques/greedy/#activity-selection-problem","title":"Activity Selection Problem","text":"<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n/*  \n    greedy choice is to \n    always pick the next activity whose \n    finish time is least among the remaining activities \n    and \n    the start time is more than or equal to the finish time of the previously selected activity. \n*/\n\nvoid printMaxActivities(int *s, int *f, int n) {\n    // it is assumed that f is sorted\n    // first activity is always selected\n    int i = 0;\n    cout &lt;&lt; i &lt;&lt; \" \";\n\n    for (int j = 1; j &lt; n; j++) {\n        if (s[j] &gt; f[i]) {\n            cout &lt;&lt; j &lt;&lt; \" \";\n            i = j;\n        }\n    }\n}\n\nint main() {\n    int s[] = {1, 3, 0, 5, 8, 5};\n    int f[] = {2, 4, 6, 7, 9, 9};\n    int n = sizeof(s) / sizeof(s[0]);\n    printMaxActivities(s, f, n);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/greedy/#job-sequencing-problem","title":"Job Sequencing Problem","text":""},{"location":"algorithms/techniques/greedy/#job-sequencing-problem-using-disjoint-set","title":"Job Sequencing Problem (Using Disjoint Set)","text":""},{"location":"algorithms/techniques/greedy/#job-sequencing-problem-loss-minimization","title":"Job Sequencing Problem - Loss Minimization","text":""},{"location":"algorithms/techniques/greedy/#job-selection-problem-loss-minimization-strategy-set-2","title":"Job Selection Problem - Loss Minimization Strategy | Set 2","text":""},{"location":"algorithms/techniques/greedy/#huffman-coding","title":"Huffman Coding","text":""},{"location":"algorithms/techniques/greedy/#efficient-huffman-coding-for-sorted-input","title":"Efficient Huffman Coding for sorted input","text":""},{"location":"algorithms/techniques/greedy/#huffman-decoding","title":"Huffman Decoding","text":""},{"location":"algorithms/techniques/greedy/#water-connection-problem","title":"Water Connection Problem","text":""},{"location":"algorithms/techniques/greedy/#policemen-catch-thieves","title":"Policemen catch thieves","text":""},{"location":"algorithms/techniques/greedy/#minimum-swaps-for-bracket-balancing","title":"Minimum Swaps for Bracket Balancing","text":""},{"location":"algorithms/techniques/greedy/#fitting-shelves-problem","title":"Fitting Shelves Problem","text":""},{"location":"algorithms/techniques/greedy/#assign-mice-to-holes","title":"Assign Mice to Holes","text":""},{"location":"algorithms/techniques/heap/","title":"Heap","text":"<ul> <li>Kth Largest Element in an Array</li> </ul>"},{"location":"algorithms/techniques/merge-intervals/","title":"Merging Intervals","text":"<ul> <li>Meeting Rooms II</li> </ul>"},{"location":"algorithms/techniques/monotonic-stack/","title":"Monotonic Stack","text":"<ul> <li>when to use stack</li> <li>when you have \\(O(n^2)\\) solution and the inner loop is dependent on j<ul> <li>then you can have better solution in \\(O(n)\\)</li> </ul> </li> </ul> <pre><code>for(int i=0;i&lt;n;i++){\n    for(int j=0;j&lt;i;j++){\n        // n^2 code complexity\n        // actually - n(n+1)/2 time complexity\n        // so we can use stack here to make it better\n    }\n}\n</code></pre> <ul> <li>note that in these solutions the amortized time complexity will be \\(O(n)\\)     even though you will be using a while loop inside a for loop.</li> </ul>"},{"location":"algorithms/techniques/monotonic-stack/#problems","title":"Problems","text":""},{"location":"algorithms/techniques/monotonic-stack/#nearest-greater-to-right","title":"Nearest greater to Right","text":"<pre><code>int n = arr.size();\nvector&lt;int&gt; ans(n, -1);\n\nstack&lt;int&gt; st;\nfor(int i=n-1;i&gt;=0;i--){\n    // check the next greater element to right of this\n    while(!st.empty() &amp;&amp; st.top() &lt;= arr[i]){\n        st.pop();\n    }\n\n    // fill the next greater element\n    if(st.empty()) ans[i] = -1;\n    else ans[i] = st.top();\n\n    // push curr one, as it can be a candidate for the other elements\n    st.push(arr[i]);\n}\n</code></pre> <p>https://leetcode.com/problems/next-greater-element-i/</p> <p>Similarly other variations are possible.</p> <ul> <li>Nearest greater to left</li> <li>Nearest smaller to right</li> <li> <p>Nearest smaller to left</p> </li> <li> <p>https://leetcode.com/problems/online-stock-span/</p> </li> </ul>"},{"location":"algorithms/techniques/randomized-algorithm/","title":"Randomized Algorithm","text":"<ul> <li>https://en.wikipedia.org/wiki/Randomized_algorithm</li> <li>https://en.wikipedia.org/wiki/Reservoir_sampling</li> </ul>"},{"location":"algorithms/techniques/sliding-window/","title":"Sliding Window","text":"<ul> <li>Longest Substring Without Repeating Characters</li> </ul>"},{"location":"algorithms/techniques/sweep-line/","title":"Sweep Line","text":""},{"location":"algorithms/techniques/two-pointer/","title":"Two Pointer","text":"<ul> <li>3Sum</li> <li>Container With Most Water</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/","title":"Dynamic Programming","text":"<ul> <li>0-1 Knapsack</li> <li>Unbounded Knapsack</li> <li>Longest Common Substring</li> <li>Matrix Chain Multiplication</li> <li>Binary Tree Problem</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/","title":"0/1 knapsack type problem","text":""},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/#description","title":"Description","text":"<ul> <li>we are given<ul> <li>two arrays - one for the weight of item and one for the price</li> <li>a value which is equal to the capacity of knapsack</li> </ul> </li> <li>for each item we have a choice<ul> <li>we should take the item</li> <li>we should not take the item</li> <li>you cannot take half of the item</li> </ul> </li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/#recursive-solution","title":"Recursive Solution","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// only things that change represent state\n// here state is -&gt; (W, n)\nint knapSack(\n    vector&lt;int&gt;wt, // weight of items array\n    vector&lt;int&gt;val, // value associated with each item\n    int W, // amount of weight we can add to knapsack\n    int n // current item + 1 number\n){\n    // base condition, when either knapsack is full, or items are over\n    if (n == 0 || W == 0) return 0;\n\n    // if current item can be stored in the knapsack\n    if (wt[n - 1] &lt;= W) {\n        return max(\n            val[n - 1] + knapSack( wt, val, W - wt[n - 1], n - 1),\n            knapSack(wt, val, W, n - 1)\n        );\n    }\n    else {\n        return knapSack(wt, val, W, n - 1);\n    }\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    cout &lt;&lt; knapSack(wt, val, W, val.size());\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/#memoization-solution","title":"Memoization solution","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// cache the state results, state is represented by (W, n), values that change\nvector&lt;vector&lt;int&gt;&gt; dp;\n\nint knapSack(vector&lt;int&gt;wt, vector&lt;int&gt;val, int W, int n){\n    // base case\n    if (n == 0 || W == 0) return 0;\n\n    // getting cache result\n    if(dp[n][W] != -1) return dp[n][W];\n\n    if (wt[n - 1] &lt;= W)\n        return dp[n][W] = max(\n            val[n - 1] + knapSack(wt, val, W - wt[n - 1], n - 1),\n            knapSack(wt, val, W, n - 1)\n        );\n    else\n        return dp[n][W] = knapSack(wt, val, W, n - 1);\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    dp = vector&lt;vector&lt;int&gt;&gt; (n+1, vector&lt;int&gt;(W+1, -1));\n    cout &lt;&lt; knapSack(wt, val, W, n);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/#top-down-approach","title":"top down approach","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint knapSack(int W, vector&lt;int&gt;wt, vector&lt;int&gt;val, int n){\n    // state cache, (n, W) represented state\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(W+1, 0));\n\n    // for base case solution is already 0, which is as initialized\n\n    // finding solution for remaining problems\n\n    // for iterating through the item state set\n    for(int i=1;i&lt;n+1;i++){\n        // for iterating though the weight state sets\n        for(int j=1;j&lt;W+1;j++){\n            if(wt[i-1] &lt;= j)\n                dp[i][j] = max(val[i-1] + dp[i-1][j-wt[i-1]], dp[i-1][j])\n            else\n                dp[i][j] = dp[i-1][j];\n        }\n    }\n\n    return dp[n][W];\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    cout &lt;&lt; knapSack(W, wt, val, n);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/0-1-knapsack/#practice-que","title":"practice que","text":"<ul> <li>0/1 knapsack<ul> <li>https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem0945/1</li> </ul> </li> <li>subset sum problem<ul> <li>https://practice.geeksforgeeks.org/problems/subset-sum-problem-1611555638/1</li> </ul> </li> <li>equal sum partition<ul> <li>https://leetcode.com/problems/partition-equal-subset-sum/</li> </ul> </li> <li>count no of subset with given sum<ul> <li>https://www.geeksforgeeks.org/count-of-subsets-with-sum-equal-to-x/</li> </ul> </li> <li>minimum subset difference problem<ul> <li>https://www.geeksforgeeks.org/partition-a-set-into-two-subsets-such-that-the-difference-of-subset-sums-is-minimum/</li> </ul> </li> <li>count the number of subset with given difference<ul> <li>https://www.geeksforgeeks.org/count-of-subsets-with-given-difference/</li> </ul> </li> <li>target sum<ul> <li>https://leetcode.com/problems/target-sum/</li> </ul> </li> <li>https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/binary-tree-problem/","title":"Binary tree problems","text":""},{"location":"algorithms/techniques/dynamic-programming/binary-tree-problem/#description","title":"Description","text":"<ul> <li>you are given a binary tree</li> <li>you calculate the result at each node</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/binary-tree-problem/#solution","title":"solution","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Node {\npublic:\n    Node *left;\n    Node *right;\n    int val;\n}\n\n// final ans\nint ans;\n\nint solve(Node *root){\n    // base case\n    if(root==NULL) return 0;\n    // hypothesis\n    int left = solve(root-&gt;left);\n    int right = solve(root-&gt;right);\n    // induction\n    // ans for node that it will pass to its parent\n    int t_ans = max(l, r) + 1; \n    int c_ans = max(t_ans, l+r+1); // candidate ans\n    ans = max(ans, c_ans);\n    return t_ans;\n}\n\nint main(){\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/binary-tree-problem/#practice-problems","title":"practice problems","text":"<ul> <li>diameter of tree problem<ul> <li>https://www.geeksforgeeks.org/diameter-of-a-binary-tree-in-on-a-new-method/</li> </ul> </li> <li>maximum path sum from leaf node to leaf node<ul> <li>https://practice.geeksforgeeks.org/problems/maximum-path-sum/1</li> </ul> </li> <li>maximum path sum from any node to any node<ul> <li>https://practice.geeksforgeeks.org/problems/maximum-path-sum-from-any-node/1</li> </ul> </li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/","title":"Longest common subsequence type problem","text":""},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/#description","title":"description","text":"<ul> <li>you are given an two array or and string</li> <li>to compare two ends of string and make some choice</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/#recursive-code","title":"recursive code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespaces std;\n\n// state is represented by (m, n)\n// m - 1 th item and n-1 th item\nint lcs(string X, string Y, int m, int n ){\n    // base case, we reached the end\n    if (m == 0 || n == 0) return 0;\n\n    // if both are equal\n    if (X[m-1] == Y[n-1]) \n        return 1 + lcs(X, Y, m-1, n-1);\n    else \n        return max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));\n}\n\nint main(){\n    string s1 = \"hithisisthis\";\n    string s2 = \"hithias\";\n    cout &lt;&lt; lcs(s1, s2, s1.length(), s2.length());\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/#memoization-sol","title":"memoization sol","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespaces std;\n\n// cache for results of state (m, n)\nvector&lt;vector&lt;int&gt;&gt; dp;\n\nint lcs(string X, string Y, int m, int n ){\n    if (m == 0 || n == 0) return 0;\n    // get results form cache\n    if(dp[m][n]!=-1) return dp[m][n];\n    if (X[m-1] == Y[n-1]) return dp[m][n] = 1 + lcs(X, Y, m-1, n-1);\n    else return dp[m][n] = max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n));\n}\n\nint main(){\n    string s1 = \"hithisisthis\";\n    string s2 = \"hithias\";\n    dp = vector&lt;vector&lt;int&gt;&gt; (s1.length()+1, vector&lt;int&gt;(s2.length()+1, -1));\n    cout &lt;&lt; lcs(s1, s2, s1.length(), s2.length());\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/#top-down-approach","title":"top down approach","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespaces std;\n\nint lcs(string X, string Y, int m, int n ){\n    vector&lt;vector&lt;int&gt;&gt; dp(s1.length()+1, vector&lt;int&gt;(s2.length()+1, 0));\n\n    // base case already initialized\n\n    for(int i=1;i&lt;m+1;i++){\n        for(int j=1;j&lt;n+1;j++){\n            if(X[m-1] == X[n-1]) dp[i][j] = 1 + dp[i-1][j-1];\n            else dp[i][j] = max(dp[i][j-1], dp[i-1][j]);\n        }\n    }\n    return dp[m][n];\n}\n\nint main(){\n    string s1 = \"hithisisthis\";\n    string s2 = \"hithias\";\n    cout &lt;&lt; lcs(s1, s2, s1.length(), s2.length());\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/longest-common-substring/#practice-problems","title":"practice problems","text":"<ul> <li>longest common subsequence<ul> <li>https://leetcode.com/problems/longest-common-subsequence/</li> </ul> </li> <li>longest common substring<ul> <li>https://practice.geeksforgeeks.org/problems/longest-common-substring1452/1</li> </ul> </li> <li>print longest common subsequence</li> <li>shortest common supersequence<ul> <li>https://leetcode.com/problems/shortest-common-supersequence/</li> </ul> </li> <li>minimum no of insertion and deletions to convert string a to string b<ul> <li>https://practice.geeksforgeeks.org/problems/minimum-number-of-deletions-and-insertions0209/1</li> </ul> </li> <li>longest palindromic subsequence</li> <li>minimum no of deletions to make a string palindrome</li> <li>print shortest common supersequence</li> <li>longest repeating subsequence<ul> <li>https://www.geeksforgeeks.org/longest-repeating-subsequence/</li> <li>https://practice.geeksforgeeks.org/problems/longest-repeating-subsequence2004/1</li> </ul> </li> <li>sequence pattern matching</li> <li>minimum no of insertions to make a string palindrome<ul> <li>https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/</li> </ul> </li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/","title":"Matrix chain multiplications type problem","text":""},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/#description","title":"description","text":"<ul> <li>you are given an array, or a string</li> <li>you have to calculate something which depends on the subarray between the range</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/#recursive-code","title":"recursive code","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// state -&gt; (i, j)\nint solve(vector&lt;int&gt; p, int i, int j) {\n    if (i == j) return 0; // base condition\n    int min = INT_MAX; // answer to return\n    for (int k = i; k &lt; j; k++) { // check all sub arrays\n        // split array into tow subarray\n        int count = solve(p, i, k) + \n                    solve(p, k + 1, j) + \n                    p[i - 1] * p[k] * p[j]; // cost of combining two subarray\n        if (count &lt; min) min = count;\n    }\n    return min;\n}\n\nint main(){\n    vector&lt;int&gt; arr = { 1, 2, 3, 4, 3 };\n    cout &lt;&lt; solve(arr, 1, arr.size() - 1);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/#memoization-sol","title":"memoization sol","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; dp;\nint solve(vector&lt;int&gt; p, int i, int j) {\n    if (i == j) return 0; // base condition\n    if(dp[i][j] != -1) return dp[i][j];\n    int min = INT_MAX; // answer to return\n    for (int k = i; k &lt; j; k++) { // check all sub arrays\n        // split array into tow subarray\n        int count = solve(p, i, k) + \n                    solve(p, k + 1, j) + \n                    p[i - 1] * p[k] * p[j]; // cost of combining two subarray\n        if (count &lt; min) min = count;\n    }\n    return dp[i][j] = min;\n}\n\nint main(){\n    vector&lt;int&gt; arr = { 1, 2, 3, 4, 3 };\n    int n = arr.size();\n    dp = vector&lt;vector&lt;int&gt;&gt; (n+1, vector&lt;int&gt; (n+1, -1));\n    cout &lt;&lt; solve(arr, 1, n - 1);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/#top-down-approach","title":"top down approach","text":"<pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint solve(vector&lt;int&gt; p) {\n    int n = p.size();\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt; (n+1, 0));\n\n    // length of subarray you will traverse\n    for(int len=2;len&lt;n+1;len++){\n        for(int i=1;i&lt;= n-len+1; i++){\n            int j=i+len-1;\n            dp[i][j] = INT_MAX;\n            for (int k = i; k &lt; j; k++) {\n                int count = dp[i][k] + dp[i+1][k] + p[i - 1] * p[k] * p[j];\n                dp[i][j] = min(dp[i][j], count);\n            }\n        }\n    }\n    return dp[n][b];\n}\n\nint main(){\n    vector&lt;int&gt; arr = { 1, 2, 3, 4, 3 };\n    int n = arr.size();\n    cout &lt;&lt; solve(arr, 1, n - 1);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/matrix-chain-multiplication/#practice-question","title":"practice question","text":"<ul> <li>matrix chain multiplication<ul> <li>https://practice.geeksforgeeks.org/problems/matrix-chain-multiplication0303/1</li> </ul> </li> <li>palindrome partitioning<ul> <li>https://leetcode.com/problems/palindrome-partitioning/</li> </ul> </li> <li>evaluate expression to true boolean parenthesization<ul> <li>https://practice.geeksforgeeks.org/problems/boolean-parenthesization5610/1</li> </ul> </li> <li>scrambled string<ul> <li>https://leetcode.com/problems/scramble-string/</li> </ul> </li> <li>egg dropping problem</li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/","title":"Unbounded knapsack type problem","text":""},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/#description","title":"Description","text":"<ul> <li>we are given<ul> <li>two arrays - one for the weight of item and one for the price</li> <li>a value which is equal to the capacity of knapsack</li> </ul> </li> <li>for each item we have a choice<ul> <li>we should take the item multiple times</li> <li>we should not take the item</li> <li>you cannot take half of the item</li> </ul> </li> </ul>"},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/#recursive-sol","title":"recursive sol","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// state represented by (W, n)\nint knapSack(vector&lt;int&gt;wt, vector&lt;int&gt;val, int W, int n){\n    // base case, items are over or knapsack is full\n    if (n == 0 || W == 0) return 0;\n    // can we add current item\n    if (wt[n - 1] &lt;= W)\n        return max(\n            val[n - 1] + knapSack(wt, val, W - wt[n - 1], n), // use item and remain on same item\n            knapSack(wt, val, W, n - 1) // mode to next item\n        );\n    else\n        return knapSack(wt, val, W, n - 1); // move to next item\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    cout &lt;&lt; knapSack(wt, val, W, val.size());\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/#memoization-solution","title":"memoization solution","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// cache for storing result of the cache -&gt; (W, n)\nvector&lt;vector&lt;int&gt;&gt; dp;\n\nint knapSack(vector&lt;int&gt;wt, vector&lt;int&gt;val, int W, int n){\n    if (n == 0 || W == 0) return 0;\n\n    // get result form the cache\n    if(dp[n][W] != -1) return dp[n][W];\n    if (wt[n - 1] &lt;= W)\n        return dp[n][W] = max(\n            val[n - 1] + knapSack(wt, val, W - wt[n - 1], n),\n            knapSack(wt, val, W, n - 1)\n        );\n    else\n        return dp[n][W] = knapSack(wt, val, W, n - 1);\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    dp = vector&lt;vector&lt;int&gt;&gt; (n+1, vector&lt;int&gt;(W+1, -1));\n    cout &lt;&lt; knapSack(wt, val, W, n);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/#top-down-approach","title":"top down approach","text":"<pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint knapSack(int W, vector&lt;int&gt;wt, vector&lt;int&gt;val, int n){\n\n    // storing results for the state (W, n)\n    // state results array\n    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(W+1, 0));\n\n    // basecases are already initialized to 0\n\n    // iterating over rest of the states\n\n    // going through items\n    for(int i=1;i&lt;n+1;i++){\n        // going through weight\n        for(int j=1;j&lt;W+1;j++){\n            if(wt[i-1] &lt;= j)\n                dp[i][j] = max(\n                        val[i-1] + dp[i][j-wt[i-1]], \n                        dp[i-1][j]\n                )\n            else\n                dp[i][j] = dp[i-1][j];\n        }\n    }\n    return dp[n][W];\n}\n\nint main(){\n    vector&lt;int&gt; val = { 60, 100, 120 };\n    vector&lt;int&gt; wt = { 10, 20, 30 };\n    int n = val.size();\n    int W = 50;\n    cout &lt;&lt; knapSack(W, wt, val, n);\n    return 0;\n}\n</code></pre>"},{"location":"algorithms/techniques/dynamic-programming/unbounded-knapsack/#practice-que","title":"practice que","text":"<ul> <li>unbounded knapsack<ul> <li>https://www.geeksforgeeks.org/unbounded-knapsack-repetition-items-allowed/</li> </ul> </li> <li>rod cutting problem<ul> <li>https://practice.geeksforgeeks.org/problems/rod-cutting0840/1</li> </ul> </li> <li>coin change problem - maximum no. of ways<ul> <li>https://leetcode.com/problems/coin-change/</li> </ul> </li> <li>coin change problem - minimum no of coins</li> </ul>"},{"location":"analysis/amortized-complexity/","title":"Amortized Complexity","text":""},{"location":"analysis/masters-theorem/","title":"Master's Theorem","text":"<ul> <li>used for recurrence relations</li> <li>for example divide and conquer</li> </ul> \\[ T(n) = a \\times T \\left( \\frac{n}{b} \\right)  + f(n) \\] <p>here</p> <ul> <li>\\(n\\) is the size of sample input</li> </ul> <p>also,</p> <ul> <li>\\(n/b\\)  in how many parts we divided the problems</li> <li>and \\(f(n)\\) is the complexity of merging those parts</li> <li>\\(a\\) no of subproblem</li> </ul> \\[ T(n) = b^{c_{crit}} \\times T\\left(\\frac{n}{b}\\right) + f(n) \\] \\[ T(n) = b^{c_{crit}} \\times T\\left(\\frac{n}{b}\\right) + O(n^c) \\] <ul> <li>\\(c &lt; c_{crit}\\)<ul> <li>\\(T(n) = \\Theta(n^{c_{crit}})\\)</li> </ul> </li> <li>\\(c &gt; c_{crit}\\)<ul> <li>\\(T(n) = \\Theta(n^{c})\\)</li> </ul> </li> <li>\\(c = c_{crit}\\)<ul> <li>\\(T(n) = \\Theta(n^c \\log n)\\)<ul> <li>another thing is, if \\(f(n) = \\Theta(n^{c_{crit}} \\log^k n)\\)<ul> <li>\\(k &gt; -1\\) then \\(T(n) = \\Theta(n^c \\log^{k+1} n)\\)</li> <li>\\(k = -1\\) then \\(T(n) = \\Theta(n^c \\log \\log n)\\)</li> <li>\\(k &lt; -1\\) then \\(T(n) = \\Theta(n^c)\\)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"analysis/p-np/","title":"P vs NP","text":""},{"location":"analysis/p-np/#p-polynomial-time","title":"P - polynomial time","text":"<ul> <li>problems which can be solved in polynomial time</li> <li>they can also be verified in polynomial time</li> <li>like sorting, searching in array</li> </ul>"},{"location":"analysis/p-np/#np-non-deterministic-polynomial-time","title":"NP - non deterministic polynomial time","text":"<ul> <li>problems which can be verified in polynomial time</li> <li>till now<ul> <li>they cannot be solved using polynomial time</li> <li>in future they can be solve if \\(P=NP\\)</li> </ul> </li> <li>like verifying if a jigsaw puzzle is valid or if a sudoku puzzle is valid</li> </ul>"},{"location":"analysis/p-np/#p-vs-np_1","title":"P vs NP","text":"<ul> <li>this problem states is it possible if a problem in verifiable in polynomial time   is it also solvable in polynomial time?</li> </ul>"},{"location":"analysis/p-np/#np-complete","title":"NP-Complete","text":"<ul> <li>\\(C\\) problem is NP-complete if<ul> <li>\\(C\\) is NP</li> <li>every problem in NP is reducible \\(C\\) in polynomial time,   if the first condition is not satisfied but the the second one is   then it is NP-Hard Problem.</li> </ul> </li> </ul>"},{"location":"analysis/p-np/#np-hardness","title":"NP-Hardness","text":"<ul> <li>problem \\(H\\) is NP-hard when<ul> <li>every problem \\(L\\) in NP can ve reduced in polynomial time to \\(H\\)</li> </ul> </li> <li>problem at least as hard as the problem in NP</li> <li>e.g. subset sum</li> <li>finding a polynomial time solution to any NP-hard problem would give   polynomial time to solve all problems in NP.</li> </ul>"},{"location":"analysis/p-np/#tldr","title":"tldr","text":"<ul> <li>p - solves polynomial time and verifies them in polynomial time<ul> <li>e.g. linear search</li> </ul> </li> <li>np - verifies problem in polynomial time<ul> <li>eg</li> </ul> </li> <li>np-complete<ul> <li>is np</li> <li>and every problem in np can be converted to this one in polynomial time</li> <li>e.g. - subset sum when all no are positive</li> </ul> </li> <li>np-hard<ul> <li>is not np - cannot be verified in polynomial time</li> <li>every problem in np can be mapped to this one in some way</li> <li>e.g. - subset sum problem</li> </ul> </li> </ul>"},{"location":"analysis/p-np/#what-if-pnp","title":"what if P=NP","text":"<ul> <li>then P=NP=NP-complete</li> <li>then every problem that is verifiable in polynomial time will also be solvable   in polynomial time.</li> </ul>"},{"location":"analysis/p-np/#what-if-pnp_1","title":"what if P!=NP","text":"<ul> <li>this is more likely what will happen</li> <li>it this happen<ul> <li>NP problems will not be solvable in polynomial time</li> </ul> </li> </ul>"},{"location":"analysis/p-np/#np-complete-problems-list","title":"NP complete problems list","text":"<p>Some NP complete problems and there descriptions.</p>"},{"location":"analysis/p-np/#sat-boolean-satisfiability-problem","title":"SAT - boolean satisfiability problem","text":"<ul> <li>Problem<ul> <li>if there exists an interpretation that satisfies a given boolean formula</li> <li>in simple terms given a boolean expression<ul> <li>what are the possible values of variables in that expression for which the answer is true</li> </ul> </li> </ul> </li> </ul>"},{"location":"analysis/p-np/#hamiltonian-path-cycle","title":"Hamiltonian Path Cycle","text":"<ul> <li> <p>Problem</p> <ul> <li>determining whether a hamintonian path or a hamintonian cycle exists or not</li> </ul> </li> <li> <p>hamiltonian path</p> <ul> <li>visit each vertex once</li> <li>if you end up at the starting vertex it becomes cycle</li> </ul> </li> </ul>"},{"location":"analysis/p-np/#knapsack-problem","title":"Knapsack Problem","text":"<ul> <li>given a knapsack and its capacity</li> <li>and some items are given with there weight and value</li> </ul> <p>0/1 knapsack</p> <ul> <li>you have to pick zero or one item of each type</li> <li>and maximize the total value</li> </ul> <p>bounded knapsack</p> <ul> <li>you have to pick zero or more items of each type</li> <li>and maximize the total value</li> </ul>"},{"location":"analysis/p-np/#traveling-salesman-problem","title":"Traveling Salesman Problem","text":"<ul> <li>given list of cities and the distances between each pairs of cities, what is the   shortest possible route that visits each city exactly once and return the city of origin.</li> </ul>"},{"location":"analysis/p-np/#subset-sum-problem","title":"Subset sum problem","text":"<ul> <li>given array and some number N</li> <li>find the subset whose sum is closest to N</li> </ul>"},{"location":"analysis/time-complexity/","title":"Time Complexity","text":""},{"location":"analysis/time-complexity/#time-complexity-from-constraints","title":"Time Complexity from Constraints","text":"<p>By looking at the constraints of a problem, we can often \"guess\" the solution.</p>"},{"location":"analysis/time-complexity/#common-time-complexities","title":"Common time complexities","text":"<p>Let \\(n\\) be the main variable in the problem.</p> <ul> <li>\\(n \\le 12\\) \\(\\rightarrow\\) \\(O(n!)\\)</li> <li>\\(n \\le 25\\) \\(\\rightarrow\\) \\(O(2^n)\\)</li> <li>\\(n \\le 100\\) \\(\\rightarrow\\) \\(O(n^4)\\)</li> <li>\\(n \\le 500\\) \\(\\rightarrow\\) \\(O(n^3)\\)</li> <li>\\(n \\le 10^4\\) \\(\\rightarrow\\) \\(O(n^2)\\)</li> <li>\\(n \\le 10^6\\) \\(\\rightarrow\\) \\(O(n \\log(n))\\)</li> <li>\\(n \\le 10^8\\) \\(\\rightarrow\\) \\(O(n)\\)</li> <li>\\(n &gt; 10^8\\) \\(\\rightarrow\\) \\(O(\\log(n))\\) or \\(O(1)\\)</li> </ul> <p>Examples of each common time complexity</p> <ul> <li>\\(O(n!)\\)<ul> <li>[Factorial time]: Permutations of \\(1 ... n\\)</li> </ul> </li> <li>\\(O(2^n)\\)<ul> <li>[Exponential time]: Exhaust all subsets of an array of size \\(n\\)</li> </ul> </li> <li>\\(O(n^3)\\)<ul> <li>[Cubic time]: Exhaust all triangles with side length less than \\(n\\)</li> </ul> </li> <li>\\(O(n^2)\\)<ul> <li>[Quadratic time]: Slow comparison-based sorting (eg. Bubble Sort, Insertion Sort, Selection Sort)</li> </ul> </li> <li>\\(O(n log(n))\\)<ul> <li>[Linearithmic time]: Fast comparison-based sorting (eg. Merge Sort)</li> </ul> </li> <li>\\(O(n)\\)<ul> <li>[Linear time]: Linear Search (Finding maximum/minimum element in a 1D array), Counting Sort</li> </ul> </li> <li>\\(O(log(n))\\)<ul> <li>[Logarithmic time]: Binary Search, finding GCD (Greatest Common Divisor) using Euclidean Algorithm</li> </ul> </li> <li>\\(O(1)\\)<ul> <li>[Constant time] Calculation (eg. Solving linear equations in one unknown)</li> </ul> </li> </ul>"},{"location":"analysis/time-complexity/#explanations-based-on-codeforces-problems","title":"Explanations based on Codeforces problems","text":"<ul> <li> <p>255D Mr. Bender and Square</p> <ul> <li>Observe that \\(1&lt;=n\\),\\(c&lt;=109\\).</li> <li>Referring to the information above, the program's time complexity should be either   \\(O(\\log n)\\) or \\(O(1)\\).</li> <li>Since no \\(O(1)\\) solution exists, we conclude that binary search must be used.</li> </ul> </li> <li> <p>580B Kefa and Company</p> <ul> <li>In this problem, \\(1 \\le n \\le1 05\\),</li> <li>which suggests that the time complexity can be either \\(O(n \\log n)\\) or \\(O(n)\\).</li> <li>It is quite obvious that sorting is required.</li> <li>Therefore, \\(O(n \\log n)\\) is the correct solution of this problem.</li> </ul> </li> <li> <p>583B Robot's Task</p> <ul> <li>Notice that n in very small \\((1\\le n \\le1000)\\) in this problem.</li> <li>It means that a \\(O(n^2)\\) solution can solve it.</li> <li>We simply need to simulate the robot's moves.</li> </ul> </li> </ul> <p>Note: The above method may not always work in all problems. Some may require algorithms that have complex time complexities, while in some problems like 591B Rebranding, the range of n does not match the time complexity of the \"optimal\" solution. (\\(1 \\le n,m \\le 200000\\) suggests that the time complexity is \\(O(n \\log n)\\) or \\(O(n)\\) but the time complexity of the solution is actually \\(O(1)\\).)</p>"},{"location":"competitive-programming/","title":"Competitive Programming","text":"<p>Competitive Programming is a sport which will help you to utilize the knowledge of algorithms and data structures.</p>"},{"location":"competitive-programming/c%2B%2B/","title":"C++ Programming","text":""},{"location":"competitive-programming/c%2B%2B/#string","title":"string","text":"<ul> <li><code>.length()</code> <code>size()</code> - return the length</li> <li><code>[]</code> - get/set value of string</li> <li><code>.reserve(size)</code> - reserve size for the string</li> <li><code>+=</code> - append</li> <li><code>append(string)</code> - append another string</li> <li><code>insert(index, string)</code> - insert string at index</li> <li><code>substr(start, size)</code> - get a substring of size from start index</li> <li><code>std::to_string(int)</code> - integer to string</li> <li><code>stoi(string)</code> - string to integer</li> <li><code>stof(string)</code> - string to float</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#arrays-raw-arrays","title":"arrays, raw arrays","text":"<ul> <li><code>[]</code> - get/set value at a index</li> <li><code>sizeof(arr)/sizeof(arr[0])</code> - get size of arr</li> <li>can be of only fixed size, <code>int arr[SIZE]</code></li> <li>for variable size use pointers, <code>int *arr = new int[n]; delete[] arr;</code></li> <li>fill array with a particular value, <code>memset(arr, 0, sizeof(arr));</code></li> </ul>"},{"location":"competitive-programming/c%2B%2B/#vector","title":"<code>vector</code>","text":"<ul> <li><code>push_back(value)</code> - add value to end of vector</li> <li><code>[index]</code> - get/set value at index</li> <li><code>size()</code> - return the size of vector</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#unordered_map-and-map","title":"<code>unordered_map</code> and <code>map</code>","text":"<ul> <li><code>[index]</code> - get/set value for a key</li> <li><code>find(key)</code> - find if key is present in map, return <code>map.end()</code> iterator if not present</li> <li><code>erase(key)</code> - remove element from the map</li> <li><code>clear()</code> - remove all elements</li> <li><code>size()</code> - return total elements in the map</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#unordered_set-and-set","title":"<code>unordered_set</code> and <code>set</code>","text":"<ul> <li><code>insert(value)</code> - insert value in set</li> <li><code>erase(value)</code> - erase value from set</li> <li><code>find(value)</code> - find value in set, if not present return <code>set.end()</code></li> <li><code>contains(value)</code> - return <code>true</code> if value exists</li> <li><code>size()</code> - return total elements in the set</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#stack","title":"<code>stack</code>","text":"<ul> <li><code>push(value)</code> - push values in the stack</li> <li><code>pop()</code> - remove top element from the stack</li> <li><code>top()</code> - return top element form the stack</li> <li><code>empty()</code> - return <code>true</code> if stack is empty</li> <li><code>size()</code> - return number of total elements in the stack</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#queue","title":"<code>queue</code>","text":"<ul> <li><code>push(value)</code> - push value at back of queue</li> <li><code>pop()</code> - remove value from front of queue</li> <li><code>front()</code> - return the element at front of queue</li> <li><code>back()</code> - return the element at end of queue</li> <li><code>empty()</code> - return if queue is empty</li> <li><code>size()</code> - return the size of the queue</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#priority_queue","title":"<code>priority_queue</code>","text":"<ul> <li>how to create for pq for particular <code>type</code><ul> <li><code>priority_queue&lt;type, vector&lt;type&gt;, TypeComparator&gt;</code></li> <li><code>struct TypeComparator {bool operator()(type a, type b) {return a &gt; b; // custom logic }};</code></li> </ul> </li> <li>by default max heap is there<ul> <li>for min heap <code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_heap;</code></li> </ul> </li> <li><code>push(value)</code> - push value and maintain in heap</li> <li><code>pop()</code> - remove the largest value(depending upon how you created) form the heap</li> <li><code>top()</code> - return the top element</li> <li><code>empty()</code> - check if heap is empty</li> <li><code>size()</code> - return the number of elements</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#deque-double-ended-queue","title":"<code>deque</code> - double ended queue","text":"<ul> <li><code>push_front(value)</code> - insert value at front</li> <li><code>push_back(value)</code> - insert value at back</li> <li><code>pop_front()</code></li> <li><code>pop_back()</code></li> <li><code>front()</code></li> <li><code>back()</code></li> <li><code>size()</code></li> </ul>"},{"location":"competitive-programming/c%2B%2B/#bitset","title":"<code>bitset</code>","text":"<ul> <li><code>bitset&lt;SIZE&gt; bit(value)</code> - create bitset of size with value</li> <li><code>[index]</code> - get bit value at index</li> <li><code>set(index)</code> - set bit at index, i.e. set to 1</li> <li><code>reset(index)</code> - unset bit at index, i.e. set to 0</li> <li><code>flip(index)</code> - flip the bit at index</li> <li><code>count()</code> - return the number of bit set to 1</li> <li><code>any()</code> - check if any bit is set</li> <li><code>none()</code> - check if no bit is set</li> <li><code>test(index)</code> - check if bit at index is set</li> </ul>"},{"location":"competitive-programming/c%2B%2B/#list-double-linked-list","title":"<code>list</code> - double linked list","text":"<ul> <li><code>size()</code></li> </ul>"},{"location":"competitive-programming/c%2B%2B/#unordered_multimap-multimap","title":"<code>unordered_multimap</code> <code>multimap</code>","text":"<ul> <li>can contains same multiple items</li> </ul>"},{"location":"competitive-programming/codechef/","title":"CodeChef","text":""},{"location":"competitive-programming/codechef/#contests","title":"Contests","text":"<p>Their are many types of contests</p> <ul> <li>Long challenges - 3 days</li> <li>Small contests - 3 hours</li> <li>and starters</li> </ul> <p>After contest ends its problems gets convert to regular problems where you can see solutions and editorials.</p>"},{"location":"competitive-programming/codeforces/","title":"Codeforces","text":"<ul> <li>Link - https://codeforces.com/</li> </ul> <p>To get list of all problems there is a public api which contains problems and their related tags. https://codeforces.com/api/problemset.problems</p>"},{"location":"competitive-programming/codeforces/#contests","title":"Contests","text":"<p>There are two types of contests for <code>div1</code> and <code>div2</code> happen, <code>div1</code> is for experienced uses and <code>div1</code> is for uses with less experience.</p> <p>You can also start virtual contest to practice any past contest. After contest is finished editorial of every coding contest are released.</p> <p>In codeforces there is concept of hacking a problem. Which means finding some problem with question. You can also challenge someone solution if it showed as passed. You have to prove it wrong (by giving some testcase). A successful hack will also result in increase in your rating.</p>"},{"location":"competitive-programming/codeforces/#ratings-categories","title":"Ratings Categories","text":"Title Rating Newbie 0-1200 Pupil 1200-1400 Specialist 1400-1600 Expert 1600-1900 Candidate Master 1900-2100 Master 2100-2300 International Master 2300-2400 Grandmaster 2400-2600 International Grandmaster 2600-3000 Legendary Grandmaster 3000-Inf <ul> <li>Rating distributions - https://codeforces.com/blog/entry/71260</li> </ul>"},{"location":"competitive-programming/codeforces/#problem-types","title":"Problem Types","text":"<p>Here are some tags which problems have in codeforces:</p> <p><code>implementation</code> <code>math</code> <code>greedy</code> <code>dp</code> <code>data structures</code> <code>constructive algorithms</code> <code>brute force</code> <code>graphs</code> <code>sortings</code> <code>binary search</code> <code>dfs and similar</code> <code>trees</code> <code>strings</code> <code>number theory</code> <code>combinatorics</code> <code>bitmasks</code> <code>two pointers</code> <code>*special</code> <code>geometry</code> <code>dsu</code> <code>shortest paths</code> <code>divide and conquer</code> <code>probabilities</code> <code>hashing</code> <code>interactive</code> <code>games</code> <code>flows</code> <code>matrices</code> <code>string suffix structures</code> <code>fft</code> <code>graph matchings</code> <code>ternary search</code> <code>meet-in-the-middle</code> <code>expression parsing</code> <code>2-sat</code> <code>chinese remainder theorem</code> <code>schedules</code></p>"},{"location":"competitive-programming/debugging/","title":"Debugging","text":""},{"location":"competitive-programming/debugging/#debugging-using-printing","title":"Debugging using printing","text":"<ul> <li>Use this template to debug,</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nclass Debug {\npublic:\n  void print(const int &amp;x) { cout &lt;&lt; x; }\n  void print(const long &amp;x) { cout &lt;&lt; x; }\n  void print(const bool &amp;x) { cout &lt;&lt; (x ? \"true\" : \"false\"); }\n  void print(const long long &amp;x) { cout &lt;&lt; x; }\n  void print(const unsigned &amp;x) { cout &lt;&lt; x; }\n  void print(const unsigned long &amp;x) { cout &lt;&lt; x; }\n  void print(const unsigned long long &amp;x) { cout &lt;&lt; x; }\n  void print(const float &amp;x) { cout &lt;&lt; x; }\n  void print(const double &amp;x) { cout &lt;&lt; x; }\n  void print(const long double &amp;x) { cout &lt;&lt; x; }\n  void print(const char &amp;x) { cout &lt;&lt; (char)44 &lt;&lt; x &lt;&lt; (char)44; }\n  void print(const char *x) { cout &lt;&lt; (char)34 &lt;&lt; x &lt;&lt; (char)34; }\n  void print(const string &amp;x) { cout &lt;&lt; (char)34 &lt;&lt; x &lt;&lt; (char)34; }\n  template &lt;typename T, typename V&gt; void print(const pair&lt;T, V&gt; &amp;x) {\n    cout &lt;&lt; '{';\n    print(x.first);\n    cout &lt;&lt; ',';\n    print(x.second);\n    cout &lt;&lt; \"}\";\n  }\n  template &lt;typename T, typename V, typename U&gt;\n  void print(const tuple&lt;T, V, U&gt; &amp;x) {\n    cout &lt;&lt; '{';\n    print(get&lt;0&gt;(x));\n    cout &lt;&lt; ',';\n    print(get&lt;1&gt;(x));\n    cout &lt;&lt; ',';\n    print(get&lt;2&gt;(x));\n    cout &lt;&lt; \"}\";\n  }\n  template &lt;typename T&gt; void print(const vector&lt;T&gt; &amp;x) {\n    cout &lt;&lt; \"{\";\n    for (int i = 0; i &lt; x.size(); i++) {\n      print(x[i]);\n      cout &lt;&lt; (x.size() - i - 1 ? \",\" : \"\");\n    };\n    cout &lt;&lt; \"}\";\n  }\n  template &lt;typename T&gt; void print(const T &amp;x) {\n    int f = 0;\n    cout &lt;&lt; '{';\n    for (auto &amp;i : x)\n      cout &lt;&lt; (f++ ? \",\" : \"\"), print(i);\n    cout &lt;&lt; \"}\";\n  }\n  void dprint() { cout &lt;&lt; \"]\\n\"; }\n  template &lt;typename T, typename... V&gt; void dprint(T t, V... v) {\n    print(t);\n    if (sizeof...(v))\n      cout &lt;&lt; \", \";\n    dprint(v...);\n  }\n};\n\nDebug d;\n#ifndef ONLINE_JUDGE\n#define debug(x...)                                                            \\\n  cout &lt;&lt; \"[\" &lt;&lt; #x &lt;&lt; \"] = [\";                                                \\\n  d.dprint(x)\n#else\n#define debug(x...)\n#endif\n\nint main() {\n  int a = 10;\n  int b = 100;\n  bool c = false;\n  long long D = 10000;\n  unsigned e = 10000;\n  unsigned long f = 1000;\n  unsigned long long g = 100;\n  float h = 123.323;\n  double i = 312.32;\n  long double j = 213.312;\n  char k = 'k';\n  string s = \"dasdas\";\n  debug(a);\n  debug(b);\n  debug(c);\n  debug(D);\n  debug(e);\n  debug(f);\n  debug(g);\n  debug(h);\n  return 0;\n}\n</code></pre>"},{"location":"competitive-programming/debugging/#debugging-using-a-debugger","title":"Debugging using a debugger","text":"<p>Debugger is a program that helps to debug a program. As simple as this definition may seems, debugger is a quite powerful tool if utilized properly. What debugger does is it compiles a program but add additional information to the program and while running you can check which line of code is causing error.</p> <p>Here is basic functionalities of a debugger</p> <ul> <li>Start - starts the execution of the program</li> <li>Stop - stops the execution of the program</li> <li>Restart - restart the code execution</li> <li>Continue - continue running code till next breakpoint</li> <li>Next - continue execution till next line of code</li> <li>Previous - rollback execution to previous line of code</li> <li>Step in - step inside the function call if present</li> <li>Step out - continue execution till getting outside of the function</li> </ul> <p>While debugging you are also provided with a debug console where you can perform operations on the current variables in scope.</p>"},{"location":"competitive-programming/famous-problems/","title":"Famous Problems","text":"<ul> <li>https://en.wikipedia.org/wiki/Longest_increasing_subsequence</li> </ul>"},{"location":"competitive-programming/java/","title":"Java Programming","text":""},{"location":"competitive-programming/java/#arrays","title":"arrays","text":"<ul> <li><code>[index]</code> - get/set at index</li> <li><code>.length</code> - get the size of array</li> <li><code>int[] arr = new int[size]</code> - create array of size <code>size</code></li> </ul>"},{"location":"competitive-programming/java/#arraylist","title":"<code>ArrayList</code>","text":"<ul> <li><code>add(value)</code> - add value to end</li> <li><code>add(index, value)</code> - add value at index</li> <li><code>remove(index)</code> - remove value at index</li> <li><code>remove(value)</code> - remove <code>value</code> from list</li> <li><code>clear()</code> - remove all elements</li> <li><code>get(index)</code> - get item at index</li> <li><code>set(index, value)</code> - set value for given index</li> <li><code>size()</code> - size of list</li> <li><code>isEmpty()</code> - check if list is empty</li> <li><code>contains(value)</code> - check if value is present</li> <li><code>indexOf(value)</code> - get the index of value</li> <li><code>lastIndexOf(value)</code>- get the last index of value</li> <li><code>removeIf(lambda: condition)</code> - remove elements which does not match the condition</li> </ul>"},{"location":"competitive-programming/java/#hashmap-ordering-not-preserved","title":"<code>HashMap</code> (ordering not preserved)","text":"<ul> <li><code>put(key, value)</code> - insert key value pait in hashmap</li> <li><code>get(key)</code> - get value for given key</li> <li><code>remove(key)</code>- remove key value pair from map</li> <li><code>containsKey(key)</code> - check if key is present in hashmap</li> <li><code>containsValue(value)</code> - check if value exists in hashmap</li> <li><code>size()</code> - give the size of map</li> <li><code>isEmpty()</code> - check if map is empty</li> <li><code>map.keySet()</code> - get list of keys</li> <li><code>map.values()</code> - get list of values</li> <li><code>map.entrySet()</code> - get list of map entries<ul> <li><code>entry.getKey()</code> <code>entry.getValue()</code></li> </ul> </li> <li><code>getOrDefault(key, defaultValue)</code> - get key value, if not present return defaultValue</li> </ul>"},{"location":"competitive-programming/java/#hashset","title":"<code>HashSet</code>","text":"<ul> <li><code>add(value)</code></li> <li><code>remove(value)</code></li> <li><code>contains(value)</code></li> <li><code>isEmpty()</code></li> <li><code>size()</code></li> <li><code>clear()</code></li> </ul>"},{"location":"competitive-programming/java/#stack","title":"<code>Stack</code>","text":"<ul> <li><code>push(value)</code></li> <li><code>pop()</code> - removes and returns items</li> <li><code>top()</code> - returns top value</li> <li><code>isEmpty()</code></li> <li><code>size()</code></li> </ul>"},{"location":"competitive-programming/java/#queue-linkedlist-arraydeque","title":"<code>Queue</code>, <code>LinkedList</code>, <code>ArrayDeque</code>","text":"<ul> <li><code>add(item)</code> - add element to tail</li> <li><code>remove()</code> - remove head element and return</li> <li><code>peek()</code> - return head element</li> <li><code>isEmpty()</code></li> <li><code>size()</code></li> <li><code>contains()</code></li> <li><code>clear()</code></li> </ul>"},{"location":"competitive-programming/java/#priorityqueue","title":"<code>PriorityQueue</code>","text":"<ul> <li><code>add(item)</code> - add item to priority queue</li> <li><code>poll()</code> - remove and return the highest element</li> <li><code>peek()</code> - return the highest element</li> <li><code>remove(item)</code> - remove item from the priority queue</li> <li><code>contains(item)</code></li> <li><code>size()</code></li> <li><code>clear()</code></li> <li> <p>custom comparator</p> <pre><code>class PersonAgeComparator implements Comparator&lt;Person&gt; { \n    public int compare(Person p1, Person p2) {\n        return Integer.compare(p1.age, p2.age);\n    }\n}\nComparator&lt;Person&gt; byAge = new PersonAgeComparator();\n</code></pre> </li> </ul>"},{"location":"competitive-programming/java/#short-summary","title":"Short summary","text":"<ul> <li><code>HashSet</code> - implemented using hashing</li> <li><code>LinkedHashSet</code> - same as <code>HashSet</code> but it maintains insertion order</li> <li><code>TreeSet</code> - implemented using a binary search tree(Red black trees), so it can be used to access items in order</li> <li><code>ArrayList</code> - like dynamic arrays</li> <li><code>Vector</code> - like array list but synchronize, (legacy)</li> <li><code>LinkedList</code> - a simple double linked list</li> <li><code>PriorityQueue</code> - implemented using heap</li> <li><code>HashMap</code> - implemented using hashing</li> <li><code>LinkedHashMap</code> - same as <code>HashMap</code> but it maintains insertion order</li> <li><code>TreeMap</code> - implemented using binary search tree, so items can be accessed in order</li> </ul>"},{"location":"competitive-programming/leetcode/","title":"Leetcode","text":"<ul> <li>Site - https://leetcode.com/</li> </ul>"},{"location":"competitive-programming/leetcode/#contests","title":"Contests","text":"<p>There are <code>weekly contests</code> (usually occur on Sundays) and <code>biweekly contests</code> (usually occur on Saturdays). After the contest ends it's problem converts to a regular problem where you can see editorial and solutions.</p> <ul> <li>https://leetcode.com/contest/</li> </ul>"},{"location":"data-structures/","title":"Data Structures","text":"<p>Some algorithms need data to be structured in certain way for them to work efficiently. This is what data structures provide. How the data is arranged in memory is defined by data structures</p>"},{"location":"data-structures/#data-structure","title":"Data Structure","text":"<ul> <li>https://en.wikipedia.org/wiki/Data_structure</li> </ul> <p>Data structure is data organization, management and storage format that is usually chosen for efficient access to data. Data structure is a collection of data values and the relationship among them and the functions or operations that can be applied on the data.</p>"},{"location":"data-structures/#abstract-data-type","title":"Abstract data type","text":"<ul> <li>https://en.wikipedia.org/wiki/Abstract_data_type</li> <li>https://cs.stackexchange.com/questions/6678/what-is-the-difference-between-abstract-and-concrete-data-structures</li> </ul> <p>Abstract data type are mathematical model of data types. They define functionality but not how they are implemented. For e.g. <code>stack</code> provide functionality to <code>pop</code> and <code>push</code> items but it can be implemented in multiple ways. (using dynamic arrays or linked lists)</p> <p>ADT are present from the view of a user and data types from the point of view of who is going to implement it.</p> <p>Here is a small list of ADT's:</p> <ul> <li>List<ul> <li>list is a collections of items, where we can add items and remove items</li> <li>implemented using arrays, using linked list</li> <li><code>getElementAt(i)</code>, <code>find(i)</code>, <code>insert()</code>, <code>remove()</code></li> <li>list can be implemented using arrays and linked list</li> </ul> </li> <li>String<ul> <li>string is a collection of ordered characters</li> <li>usually same operations as list</li> <li>using arrays, using linked list</li> </ul> </li> <li>Set<ul> <li>set is a collection of unique items</li> <li><code>insert()</code> <code>remove()</code> <code>find()</code> <code>size()</code></li> <li>using arrays, using linked list, using linked list which are connected in form of a tree</li> </ul> </li> <li>Map<ul> <li>map is a collection of key value pairs</li> <li><code>getValue(key)</code></li> <li>using hash map</li> </ul> </li> <li>Graph<ul> <li><code>addNode()</code> <code>addEdge(x, y)</code> <code>getChildren()</code></li> <li>implemented using adjacency list, adjacency graph</li> </ul> </li> <li>Tree<ul> <li>implemented using (arrays and linked list) or using only linked list, or only using arrays</li> <li>Binary Trees are often used in context of data structures representing nodes with right and left child</li> </ul> </li> <li>Stack<ul> <li>represnets a stack of items, where we can push items and pop items</li> </ul> </li> <li>Queue<ul> <li>represents a queues of items, where we can add items at end of queue and remove items from front of queue</li> </ul> </li> </ul>"},{"location":"data-structures/#outline","title":"Outline","text":"<ul> <li>Data Structure<ul> <li>Classification:<ul> <li>Linear: static, dynamic</li> <li>Non Linear</li> </ul> </li> </ul> </li> <li>Array<ul> <li>dynamic array</li> <li>create, insert, delete</li> </ul> </li> <li>Linked List<ul> <li>Types: Single, double, circular</li> <li>Operation: insertion, deletion, searching</li> </ul> </li> <li>Stack: push, pop</li> <li>Queue:<ul> <li>Priority Queue</li> </ul> </li> <li>Tree<ul> <li>Binary Tree<ul> <li>Binary Heap</li> <li>Binary search tree<ul> <li>avl tree</li> <li>red black tree</li> <li>splay tree</li> </ul> </li> </ul> </li> <li>Segment tree</li> <li>Trie</li> <li>Binary Indexed Tree</li> <li>suffix array and suffix tree</li> <li>B-Tree</li> <li>k dimensional tree</li> </ul> </li> <li>Graph</li> <li>Hashing</li> </ul>"},{"location":"data-structures/#a-note-about-programming-language","title":"A note about programming language","text":"<ul> <li>Every languages provides some basic type of data structures and data types (primitive data types).</li> <li>If you use low level programming language you have to implement the data structures on you own and will have more control over it's execution,   but you will have to write more code.</li> </ul>"},{"location":"data-structures/abstract-data-type/dequeue/","title":"Introduction","text":"<p>Dequeue or Double Ended Queue is a generalized version of Queue data structure that allow inset and delete at both ends.</p>"},{"location":"data-structures/abstract-data-type/dequeue/#sample-implementation-of-dequeue-using-linked-list","title":"Sample Implementation of dequeue using linked list","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass Node {\npublic:\n  Node(int data) : data(data), next(nullptr), prev(nullptr) {}\n  int data;\n  Node* next;\n  Node* prev;\n};\n\nclass Dequeue {\nprivate:\n  Node* head;\n  Node* tail;\n  int capacity;\n\npublic:\n  Dequeue() : capacity(0), head(nullptr), tail(nullptr) {}\n  int front() { return head-&gt;data; }\n  int back() { return tail-&gt;data; }\n  int size() { return capacity; }\n  bool empty() { return capacity == 0; }\n\n  void push_back(int val) {\n    if (this-&gt;empty()) {\n      tail = new Node(val);\n      head = tail;\n    } else {\n      tail-&gt;next = new Node(val);\n      tail-&gt;next-&gt;prev = tail;\n      tail = tail-&gt;next;\n    }\n    capacity++;\n  }\n\n  void push_front(int val) {\n    if (this-&gt;empty()) {\n      head = new Node(0);\n      tail = head;\n    } else {\n      head-&gt;prev = new Node(val);\n      head-&gt;prev-&gt;next = head;\n      head = head-&gt;prev;\n    }\n    capacity++;\n  }\n\n  void pop_back() {\n    if (this-&gt;empty()) return;\n    Node* t = tail;\n    if (capacity == 1) {\n      head = nullptr;\n      tail = nullptr;\n    } else {\n      tail = tail-&gt;prev;\n      tail-&gt;next = nullptr;\n    }\n    delete t;\n    capacity--;\n  }\n\n  void pop_front() {\n    if (this-&gt;empty()) return;\n    Node* t = head;\n    if (capacity == 1) {\n      head = nullptr;\n      tail = nullptr;\n    } else {\n      head = head-&gt;next;\n      head-&gt;prev = nullptr;\n    }\n    delete t;\n    capacity--;\n  }\n};\n\nint main() {\n  vector&lt;int&gt; a = {1, 2, 3, 4, 5};\n  vector&lt;int&gt; aa = {10, 11, 12, 13, 14, 15};\n\n  Dequeue d;\n\n  for (int i = 0; i &lt; a.size(); i++) {\n    d.push_back(a[i]);\n  }\n  for (int i = 0; i &lt; aa.size(); i++) {\n    d.push_front(aa[i]);\n  }\n  while (!d.empty()) {\n    cout &lt;&lt; d.front() &lt;&lt; \" \";\n    d.pop_front();\n  }\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/abstract-data-type/queue/","title":"Introduction","text":"<p>Queue data structure provide First In First Out FIFO feature.</p> <p>Queues is used in different places like in BFS.</p>"},{"location":"data-structures/abstract-data-type/queue/#sample-implementation-of-queue-using-linked-list","title":"Sample Implementation of queue using linked list","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Node {\npublic:\n  Node(int data) : data(data), next(nullptr), prev(nullptr) {}\n  int data;\n  Node* next;\n  Node* prev;\n};\n\nclass Queue {\nprivate:\n  Node* head;\n  Node* tail;\n  int capacity;\n\npublic:\n  Queue() : capacity(0), head(nullptr), tail(nullptr) {}\n  int front() { return head-&gt;data; }\n  int back() { return tail-&gt;data; }\n  int size() { return capacity; }\n  bool empty() { return capacity == 0; }\n\n  void push(int val) {\n    if (this-&gt;empty()) {\n      tail = new Node(val);\n      head = tail;\n    } else {\n      tail-&gt;next = new Node(val);\n      tail-&gt;next-&gt;prev = tail;\n      tail = tail-&gt;next;\n    }\n    capacity++;\n  }\n\n  void pop() {\n    if (this-&gt;empty()) return;\n    Node* t = head;\n    if (capacity == 1) {\n      head = nullptr;\n      tail = nullptr;\n    } else {\n      head = head-&gt;next;\n      head-&gt;prev = nullptr;\n    }\n    delete t;\n    capacity--;\n  }\n};\n\nint main() {\n  Queue q;\n  vector&lt;int&gt; a = {10, 11, 12, 13, 14, 15};\n  for (auto i : a) {\n    q.push(i);\n  }\n  while (!q.empty()) {\n    cout &lt;&lt; q.front() &lt;&lt; \" \";\n    q.pop();\n  }\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/abstract-data-type/stack/","title":"Introduction","text":"<p>Stack is a data structure which provides Last In First Out (LIFO).</p> <p>Stack is used in many places like in DFS traversal, and monotonic stack is used in many algos.</p>"},{"location":"data-structures/abstract-data-type/stack/#sample-implementation-of-stack-using-arrays","title":"Sample Implementation of Stack using arrays","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Stack {\nprivate:\n  vector&lt;int&gt; storage;\n\npublic:\n  Stack() : storage(vector&lt;int&gt;()) {}\n  bool empty() { return storage.empty(); }\n  void push(int val) {\n    storage.push_back(val);\n  }\n  void pop() {\n    storage.pop_back();\n  }\n  int top() {\n    return storage.back();\n  }\n};\n\nint main() {\n  vector&lt;int&gt; aa = {10, 11, 12, 13, 14, 15};\n  Stack st;\n  for (int i : aa) st.push(i);\n\n  while (!st.empty()) {\n    cout &lt;&lt; st.top() &lt;&lt; \" \";\n    st.pop();\n  }\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/arrays/","title":"Arrays","text":"<p>Arrays are the most basic data structure. The intuition behind using arrays is that, you put your data in contiguous location. And if you want to get location of \\(i\\) th data element you can get by adding the size of each data item times \\(i\\) and the offset of the first item.</p>"},{"location":"data-structures/graphs/","title":"Graphs","text":"<ul> <li>Types of Graphs</li> <li>Graph Traversal<ul> <li>Breadth first search BFS, BFS Tree</li> <li>Depth first search DFS, DFS Tree</li> </ul> </li> <li>Union Find</li> <li>Directed Acyclic Graph (DAG)<ul> <li>Topological traversal</li> <li>Check for cycle in graph</li> </ul> </li> <li>On weighted graph<ul> <li>Find connected components<ul> <li>Kosaraju's algorithm, Tarjans Algorithm</li> </ul> </li> <li>Minimum spanning tree<ul> <li>Kruskal Algorithm, Prim algorithms, Brovuka'a Algorithm</li> </ul> </li> <li>Shortest path from source to all other nodes<ul> <li>Djkstra's Algorithm, Bellman ford's</li> </ul> </li> <li>Shortest path between all nodes to all other node<ul> <li>Floyd Warshall Algorithm, Johnson's Algorithm</li> </ul> </li> <li>Detect negative cycles</li> </ul> </li> <li>Connectivity<ul> <li>Path between two vertices</li> <li>Bridges in a graph</li> <li>Articulation Points</li> </ul> </li> <li>Traveling Salesman Problem (TSP)</li> <li>Hamiltonian Path</li> <li>Eulerian Graph</li> <li>Network Flow (max flow)<ul> <li>Ford Fulkerson Algorithm</li> </ul> </li> </ul>"},{"location":"data-structures/graphs/graph-representations/","title":"Graph Representations","text":""},{"location":"data-structures/graphs/graph-representations/#edge-list","title":"Edge List","text":"<ul> <li>this will be that usual graph representation that you will be provided   and will have to convert this to another representation</li> <li>it is a list which contains item of form, (u, v, weight)   which represents that u vertex is connected to v vertex with given weight</li> </ul>"},{"location":"data-structures/graphs/graph-representations/#adjacency-matrix","title":"Adjacency Matrix","text":"<ul> <li>given \\(n\\) vertices</li> <li>you have to create a \\(n * n\\) matrix</li> <li>the ith row and jth col will represent if the ith vertex and jth vertex are   connected or not, and if graph is weighted it can be filled with that value</li> <li>good if you have a dense graph, but takes too much space for a sparse graph</li> </ul>"},{"location":"data-structures/graphs/graph-representations/#adjacency-list","title":"Adjacency List","text":"<ul> <li>in this you create a array of list where, the list at ith index   will contains all the vertices ith vertex is connected to</li> <li>good if you have a sparse graph</li> </ul>"},{"location":"data-structures/graphs/graphs-types/","title":"Graphs Types","text":""},{"location":"data-structures/graphs/graphs-types/#sparse-graphs-vs-dense-graphs","title":"Sparse graphs vs dense graphs","text":"<ul> <li>Given graphs with \\(n\\) vertex, maximum amount of edges it can have is    \\(n(n-1)/2\\).</li> <li>Compared to that number if the vertex present are very less it is called a sparse graph, otherwise it is a dense graph.</li> </ul>"},{"location":"data-structures/graphs/graphs-types/#based-on-edge-orientation-directedundirected","title":"Based on edge orientation (directed/undirected)","text":""},{"location":"data-structures/graphs/graphs-types/#undirected-graph","title":"Undirected graph","text":"<p>In undirected graph the edge for a node \\(a\\) to \\(b\\) is considered same as node from \\(b\\) to \\(a\\).</p> Example <pre><code>flowchart LR\n    A --- B\n    A --- C\n    B --- C\n    B --- D\n    C --- E\n    D --- E</code></pre> \\[ G = (V, E) \\] <ul> <li>vertex \\(V\\) - \\(\\{a, b, c, d, e\\}\\)</li> <li>edges \\(E\\) - \\(\\{(a, b), (a, c), (b, d), (d, e)\\}\\)</li> </ul> <p>Here in \\((a, b)\\) - \\(a\\), \\(b\\) are the endpoints of the edge.</p> <ul> <li>Order of graph = no of vertices \\(|V|\\)</li> <li>Size of graph = no of edges \\(|E|\\) or for computational complexity \\(|E|+|V|\\)</li> </ul>"},{"location":"data-structures/graphs/graphs-types/#directed-graph","title":"Directed Graph","text":"<p>Also called digraph or directed simple graph.</p> Example <pre><code>flowchart LR\n    A ---&gt; B\n    A ---&gt; C\n    B ---&gt; D\n    D ---&gt; A\n    C ---&gt; E\n    D ---&gt; E</code></pre> <p>\\(G = (V, E)\\)</p> <ul> <li>\\(V\\) is set of vertices</li> <li>\\(E\\) is subset of \\(\\{(x, y) | (x, y) \\in V \\times V \\text{and } x \\ne y\\}\\)</li> </ul>"},{"location":"data-structures/graphs/graphs-types/#multigraph","title":"Multigraph","text":"<p>Generalization that allows multiple edges to have the same pair of endpoints.</p>"},{"location":"data-structures/graphs/graphs-types/#weighted-graph-and-unweighted-graph","title":"Weighted graph and Unweighted Graph","text":"<p>Unweighted graph does not have any score associate with edges.</p> <p>Weighted graph have a score associated with each edge.</p> <p>For example in case of a map the distance between two locations. We can add to any type of graph and it will be considered weighted graph. So we can have weighted directed graph, weighted undirected graph and so on.</p>"},{"location":"data-structures/graphs/graphs-types/#directed-acyclic-graph-dag","title":"Directed acyclic graph (DAG)","text":"<p>DAG is a directed graph with no directed cycles. That is, it consists of vertices and edges (also called arcs), with each edge directed from one vertex to another, such that following those directions will never form a closed loop.</p> <p></p>"},{"location":"data-structures/graphs/graphs-types/#regular-graph","title":"Regular graph","text":"<p>A regular graph is a graph in which each vertex has the same number of neighbors, i.e., every vertex has the same degree.</p> <ul> <li>https://en.wikipedia.org/wiki/Regular_graph</li> </ul>"},{"location":"data-structures/graphs/graphs-types/#complete-graph","title":"Complete graph","text":"<p>A complete graph is a graph in which each pair of vertices is joined by an edge. A complete graph contains all possible edges.</p> <p>Total no of edges = \\(n (n-1) / 2\\)</p> <ul> <li>https://en.wikipedia.org/wiki/Complete_graph</li> </ul>"},{"location":"data-structures/graphs/graphs-types/#connected-graph","title":"Connected graph","text":""},{"location":"data-structures/graphs/graphs-types/#for-undirected-graphs","title":"For undirected graphs","text":"<p>In an <code>undirected graph</code>, an unordered pair of vertices \\((x, y)\\) is called <code>connected</code> if a path leads from \\(x\\) to \\(y\\). Otherwise, the unordered pair is called <code>disconnected</code>.</p> <p>A connected graph is an undirected graph in which every unordered pair of vertices in the graph is connected. Otherwise, it is called a disconnected graph.</p>"},{"location":"data-structures/graphs/graphs-types/#for-directed-graphs","title":"For directed graphs","text":"<p>In a directed graph, an ordered pair of vertices \\((x, y)\\) is called</p> <ul> <li>strongly connected if a directed path leads from \\(x\\) to \\(y\\)</li> <li>weakly connected if an undirected path leads from \\(x\\) to \\(y\\)   after replacing all of its directed edges with undirected edges</li> <li>otherwise, the ordered pair is called disconnected</li> </ul> <p>A strongly connected graph is a directed graph in which every ordered pair of vertices in the graph is strongly connected.</p> <p>Otherwise, it is called a weakly connected graph if every ordered pair of vertices in the graph is weakly connected. Otherwise it is called a disconnected graph.</p> <p>A k-vertex-connected graph or k-edge-connected graph is a graph in which no set of \\(k - 1\\) vertices (respectively, edges) exists that, when removed, disconnects the graph. A k-vertex-connected graph is often called simply a k-connected graph.</p>"},{"location":"data-structures/graphs/graphs-types/#bipartite-graph","title":"Bipartite graph","text":"<p>A bipartite graph is a simple graph in which the vertex set can be partitioned into two sets, \\(W\\) and \\(X\\), so that no two vertices in \\(W\\) share a common edge and no two vertices in \\(X\\) share a common edge. Alternatively, it is a graph with a chromatic number of 2.</p> <p></p>"},{"location":"data-structures/graphs/graphs-types/#planar-graph","title":"Planar graph","text":"<p>A planar graph is a graph whose vertices and edges can be drawn in a plane such that no two of the edges intersect.</p>"},{"location":"data-structures/graphs/graphs-types/#cycle-graph","title":"Cycle graph","text":"<p>A cycle graph or circular graph of order \\(n \\ge 3\\) is a graph in which the vertices can be listed in an order \\(v_1, v_2, \\cdots, v_n\\) such that the edges are the \\(\\{v_i, v_{i+1}\\}\\) where \\(i = 1, 2, \\cdots, n - 1\\), plus the edge \\(\\{v_n, v_1\\}\\). Cycle graphs can be characterized as connected graphs in which the degree of all vertices is 2. If a cycle graph occurs as a subgraph of another graph, it is a cycle or circuit in that graph.</p>"},{"location":"data-structures/graphs/graphs-types/#tree","title":"Tree","text":"<p>A tree is an undirected graph in which any two vertices are connected by exactly one path, or equivalently a connected acyclic undirected graph.</p> <p>A forest is an undirected graph in which any two vertices are connected by at most one path, or equivalently an acyclic undirected graph, or equivalently a disjoint union of trees.</p>"},{"location":"data-structures/graphs/terminology/","title":"Some common graph terminology","text":"<ul> <li>https://en.wikipedia.org/wiki/Glossary_of_graph_theory</li> </ul>"},{"location":"data-structures/graphs/terminology/#connected-components","title":"Connected components","text":"<ul> <li> <p>A component of a undirected graph is a connected subgraph   that is not part of any larger connected subgraph.</p> </li> <li> <p>https://en.wikipedia.org/wiki/Component_(graph_theory)</p> </li> </ul>"},{"location":"data-structures/graphs/terminology/#strongly-connected-components-scc","title":"Strongly connected components (SCC)","text":"<ul> <li>for directed graphs</li> <li>a digraph is said to be strongly connected if every vertex can be reached   from every other vertex</li> <li> <p>the scc of a digraph form a partition into subgraphs that are themselves strongly connected</p> </li> <li> <p>https://en.wikipedia.org/wiki/Strongly_connected_component</p> </li> </ul>"},{"location":"data-structures/graphs/terminology/#bridges-isthmus-cut-edge-or-cut-arc","title":"Bridges (isthmus, cut-edge, or cut arc)","text":"<ul> <li>a edge in graph whose removal increase the number of connected components</li> </ul>"},{"location":"data-structures/graphs/terminology/#articulation-points-cut-vertex","title":"Articulation Points (cut vertex)","text":"<ul> <li>vertex which when removed along with associated edges, increases the   connected components</li> </ul>"},{"location":"data-structures/graphs/terminology/#clique","title":"Clique","text":"<ul> <li> <p>Clique is a subset of vertices of undirected graph, such that every two   distinct vertices in clique are adjacent.</p> </li> <li> <p>https://en.wikipedia.org/wiki/Clique_(graph_theory)</p> </li> </ul>"},{"location":"data-structures/linked-list/","title":"Introduction","text":"<p>Linked list consists of node where each nodes contains a data field and a reference (link) to the next node in the list.</p> <p>A double linked list contains one more reference to the previous node in the list.</p>"},{"location":"data-structures/linked-list/#single-linked-list","title":"Single Linked List","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Node {\npublic:\n  int data;\n  Node* next;\n  Node(int data, Node* next) : data(data), next(next) {}\n  Node(int data) : data(data), next(nullptr) {}\n};\n\nint main() {\n  vector&lt;int&gt; a = {1, 2, 3, 4, 5};\n  Node* head = new Node(a[0]);\n\n  Node* t = head;\n  for (int i = 1; i &lt; a.size(); i++) {\n    t-&gt;next = new Node(a[i]);\n    t = t-&gt;next;\n  }\n  // print\n  t = head;\n  while (t != nullptr) {\n    cout &lt;&lt; t-&gt;data &lt;&lt; \"-&gt;\";\n    t = t-&gt;next;\n  }\n  cout &lt;&lt; \"NULL\\n\";\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/linked-list/#double-linked-list","title":"Double Linked List","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Node {\npublic:\n  int data;\n  Node* next;\n  Node* prev;\n  Node(int data, Node* next, Node* prev) : data(data), next(next), prev(prev) {}\n  Node(int data) : data(data), next(nullptr), prev(nullptr) {}\n};\n\nint main() {\n  vector&lt;int&gt; a = {1, 2, 3, 4, 5};\n  Node* head = new Node(a[0]);\n\n  Node* t = head;\n  Node* prev = nullptr;\n  for (int i = 1; i &lt; a.size(); i++) {\n    t-&gt;next = new Node(a[i]);\n    t-&gt;prev = prev;\n    prev = t;\n    t = t-&gt;next;\n  }\n  t-&gt;prev = prev;\n\n  // print\n  t = head;\n  while (t-&gt;next != nullptr) {\n    cout &lt;&lt; t-&gt;data &lt;&lt; \"-&gt;\";\n    t = t-&gt;next;\n  }\n  while (t-&gt;prev != nullptr) {\n    cout &lt;&lt; t-&gt;data &lt;&lt; \"-&gt;\";\n    t = t-&gt;prev;\n  }\n  cout &lt;&lt; \"NULL\";\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/trees/","title":"Trees","text":"<p>Trees is recursive data structure, and algorithm related to trees are often recursive too.</p> <p>Trees</p> <ul> <li>consists of nodes</li> <li>each node can have children nodes.</li> <li>there is only one root node, a node which don't have a parent</li> <li>if there are more than one root node it is called a forest</li> </ul>"},{"location":"data-structures/trees/binary-tree/","title":"Binary Trees","text":"<p>Binary trees are tress in which each node can have atmost two child.</p> <pre><code>  *\n / \\\nL   R\n</code></pre>"},{"location":"data-structures/trees/binary-tree/#traversal","title":"Traversal","text":"<p>Tree traversal in binary tree refers to the order in which access the root node, left tree and right tree. The name of the order defines how we access the root node, and rest we always access left tree first than right tree.</p>"},{"location":"data-structures/trees/binary-tree/#pre-order","title":"Pre-order","text":"<ul> <li>pre means root first than left and right</li> </ul>"},{"location":"data-structures/trees/binary-tree/#post-order","title":"Post-order","text":"<ul> <li>post means root last, first left than right</li> </ul>"},{"location":"data-structures/trees/binary-tree/#in-order","title":"In-order","text":"<ul> <li>first left than root and than right</li> </ul>"},{"location":"data-structures/trees/binary-tree/#representation","title":"Representation","text":"<p>Binary Trees can be represented in two basic ways:</p>"},{"location":"data-structures/trees/binary-tree/#with-self-referential-structures","title":"With Self Referential Structures","text":"<pre><code>struct Node{\n    int val;\n    Node *left;\n    Node *right\n}\n</code></pre>"},{"location":"data-structures/trees/binary-tree/#with-a-array","title":"With a array","text":"<ul> <li>in this representation, child node of ith element is at \\(2*i + 1\\) and \\(2*i + 2\\) position</li> </ul>"},{"location":"data-structures/trees/binary-tree/#types","title":"Types","text":"<ul> <li>Binary heap</li> <li>Binary search tree</li> </ul>"},{"location":"data-structures/trees/binary-tree/binary-heap/","title":"Binary Heap","text":"<p>Binary heap is a binary tree in which each parent is greater than it's child node or each parent is smaller than it's parent. It is often used to implement a priority queue.</p>"},{"location":"data-structures/trees/binary-tree/binary-heap/#implementation","title":"Implementation","text":"<ul> <li>to implement a binary heap we can use either representation</li> <li>to insert a element, we inset it at the end of the tree and bubble it's way up</li> <li>to remove a top element we replace last element with the top one and bubble it's way down</li> </ul>"},{"location":"data-structures/trees/binary-tree/binary-heap/#sample-implementation","title":"Sample Implementation","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass Heap {\nprivate:\n  vector&lt;int&gt; storage;\n\n  static void heapifyHelper(vector&lt;int&gt;&amp; a, int idx) {\n    int n = a.size();\n    int largest = idx;\n    int l = 2 * idx + 1;\n    int r = 2 * idx + 2;\n    if (l &lt; n &amp;&amp; a[l] &gt; a[largest]) largest = l;\n    if (r &lt; n &amp;&amp; a[r] &gt; a[largest]) largest = r;\n\n    if (largest != idx) {\n      swap(a[idx], a[largest]);\n      heapifyHelper(a, largest);\n    }\n  }\n\npublic:\n  Heap() {\n    storage = vector&lt;int&gt;();\n  }\n\n  Heap(vector&lt;int&gt; arr) {\n    storage = vector&lt;int&gt;(arr);\n    Heap::heapify(this-&gt;storage);\n  }\n\n  void push(int val) {\n    storage.push_back(val);\n    int i = storage.size() - 1;\n    while (i &gt; 0) {\n      int parent = (i - 1) / 2;\n      if (storage[parent] &lt; storage[i]) {\n        swap(storage[parent], storage[i]);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  int top() {\n    // undefined behaviour if storage is empty\n    return storage.front();\n  }\n\n  void pop() {\n    if (storage.empty()) return;\n    storage.front() = storage.back();\n    storage.pop_back();\n    Heap::heapifyHelper(storage, 0);\n  }\n\n  inline bool empty() {\n    return storage.empty();\n  }\n\n  static void heapify(vector&lt;int&gt;&amp; a) {\n    int n = a.size();\n    for (int i = (n / 2) - 1; i &gt;= 0; i--) {\n      heapifyHelper(a, i);\n    }\n  }\n\n  static void sort(vector&lt;int&gt;&amp; arr) {\n    Heap h(arr);\n    for (int i = 0; i &lt; arr.size(); i++) {\n      arr[i] = h.top();\n      h.pop();\n    }\n  }\n};\n\nint main() {\n  vector&lt;int&gt; a = {1, 2, 54, 23, 21, 32, 31};\n  Heap h(a);\n\n  for (int i = 0; i &lt; a.size(); i++) {\n    cout &lt;&lt; h.top() &lt;&lt; \" \";\n    h.pop();\n  }\n  cout &lt;&lt; \"\\n\";\n\n  Heap::sort(a);\n  for (auto i : a) {\n    cout &lt;&lt; i &lt;&lt; \" \";\n  }\n  cout &lt;&lt; \"\\n\";\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/","title":"Binary Search Tree","text":"<p>Binary Search Trees are used for creating search trees.</p> <p>A binary search tree:</p> <ul> <li>is a binary tree</li> <li>for each node<ul> <li>its left child value is less than its value</li> <li>its right child value is more than its value</li> </ul> </li> </ul>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#traversal","title":"Traversal","text":"<p>This is same as a binary tree, but some new features emerges. Inorder traversal of a bst give a sorted list. (this fact will be used in many problems). Converse is also true, if inorder traversal give sorted list, it is bst.</p>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#searching","title":"Searching","text":"<p>Searching in binary tree is same as binary search. You start with the root node and then compare, there are three possibilities either it will be the target no., or less target no, or greater than target no.</p> <p>After checking each node, you only have to look a one of it's child tree.</p> <p>And if the tree is balanced, then the time complexity of searching will be same as binary search.</p>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#inserting","title":"Inserting","text":"<p>To insert a element, you again search for the node, and when you reach one of the leaves or one level above it, you will place it so it satisfies the BST condition.</p>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#deletion","title":"Deletion","text":"<p>First search for the node. Now three conditions arise:</p> <ul> <li>0 child - just remove the node</li> <li>1 child - put that child node in it's place</li> <li>2 child<ul> <li>now think about what will the new tree should have</li> <li>it's inorder traversal should still give a sorted list</li> <li>so this node should be replace with it's inorder successor, otherwise it will not give sorted   list and so it will also not be a bst.</li> </ul> </li> </ul> <p>You can solve this using two ways, use double pointers so you can manipulate addresses. And other easier way, use recursion to do the job.</p> <pre><code>Node *deleteNode(Node *root, int key){\n    if(root == nullptr) return nullptr;\n    if(key == root-&gt;value){\n        if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr) // no child\n            return nullptr;\n        else if(root-&gt;left == nullptr) { // one child\n            Node *temp = root-&gt;right;\n            free(root);\n            return temp;\n        } else if(root-&gt;right == nullptr){ // one child\n            Node *temp = root-&gt;left;\n            free(root);\n            return temp;\n        }\n        else { // inorder successor, both child\n            Node *temp = root-&gt;right;\n            while(temp-&gt;left!=nullptr) temp = temp-&gt;left;\n            root-&gt;value= temp-&gt;value;\n            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;value);\n        }\n    }\n    else if(key &lt; root-&gt;value) root-&gt;left = deleteNode(root-&gt;left, key);\n    else root-&gt;left = deleteNode(root-&gt;left, key);\n}\n</code></pre>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#balanced-binary-search-tree","title":"Balanced Binary Search Tree","text":"<p>Normal BST without balancing are rarely used. A unbalance bst will have a linear time complexity for searching.</p>"},{"location":"data-structures/trees/binary-tree/binary-search-tree/#types","title":"Types","text":"<ul> <li>AVL Tree</li> <li>Red-Black Tree</li> </ul>"},{"location":"data-structures/trees/binary-tree/traversal/","title":"Traversal in Binary Trees","text":""},{"location":"data-structures/trees/binary-tree/traversal/#inorder","title":"Inorder","text":"<ul> <li><code>Left -&gt; Root -&gt; Right</code></li> </ul>"},{"location":"data-structures/trees/binary-tree/traversal/#preorder","title":"Preorder","text":"<ul> <li><code>Root -&gt; Left -&gt; Right</code></li> </ul>"},{"location":"data-structures/trees/binary-tree/traversal/#postorder","title":"Postorder","text":"<ul> <li><code>Left -&gt; Right -&gt; Root</code></li> </ul>"},{"location":"data-structures/trees/segment-tree/","title":"Segment Trees","text":"<ul> <li>segment tree are useful for range queries</li> <li> <p>so it has following main parts</p> <ul> <li>construction</li> <li>query</li> <li>updating certain index</li> </ul> </li> <li> <p>so given an array we treat it as a tree</p> </li> </ul>"},{"location":"data-structures/trees/segment-tree/#code","title":"Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nclass SegmentTree {\npublic:\n  int* st;\n  int n;\n  SegmentTree(vector&lt;int&gt;&amp; a) {\n    n = a.size();\n    st = new int[4 * a.size()];\n    construct(a, 0, a.size() - 1, 0);\n  }\n\n  /* create segment tree for arr[s...e] */\n  int construct(vector&lt;int&gt;&amp; arr, int s, int e, int i) {\n    if (s == e) return st[i] = arr[s];\n    int mid = (s + e) / 2;\n    return st[i] = construct(arr, s, mid, i * 2 + 1) +\n                   construct(arr, mid + 1, e, 2 * i + 2);\n  }\n\n  int query(int s, int e, int qs, int qe, int i) {\n    if (qs &lt;= s &amp;&amp; e &lt;= qe) return st[i];\n    if (qs &gt; e || qe &lt; s) return 0;\n    int mid = (s + e) / 2;\n    return query(s, mid, qs, qe, 2 * i + 1) +\n           query(mid + 1, e, qs, qe, 2 * i + 2);\n  }\n\n  void updateUtil(int s, int e, int i0, int diff, int i) {\n    if (i0 &lt; s || i0 &gt; e) return;\n    st[i] += diff;\n    if (s != e) {\n      int mid = (s + e) / 2;\n      updateUtil(s, mid, i0, diff, 2 * i + 1);\n      updateUtil(mid + 1, e, i0, diff, 2 * i + 2);\n    }\n  }\n\n  void update(int i0, int diff) {\n    if (i0 &lt; 0 || i0 &gt; n - 1) return;\n    updateUtil(0, n - 1, i0, diff, 0);\n  }\n};\n\nint main() {\n  vector&lt;int&gt; a = {1, 3, 5, 7, 9, 11};\n  SegmentTree s(a);\n  cout &lt;&lt; s.query(0, a.size() - 1, 1, 3, 0) &lt;&lt; endl;\n  s.update(1, 7);\n  cout &lt;&lt; s.query(0, a.size() - 1, 1, 3, 0) &lt;&lt; endl;\n  return 0;\n}\n</code></pre>"},{"location":"data-structures/trees/segment-tree/#references","title":"References","text":"<ul> <li>https://wcipeg.com/wiki/Segment_tree</li> <li>https://en.wikipedia.org/wiki/Segment_tree</li> <li>https://cp-algorithms.com/data_structures/segment_tree.html</li> </ul>"},{"location":"data-structures/trees/trie/","title":"Trie","text":"<ul> <li>Word Search II</li> <li>Implement Trie</li> </ul>"}]}